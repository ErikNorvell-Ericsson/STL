"/*\r\n"
" * (C) 2022 copyright VoiceAge Corporation. All Rights Reserved.\r\n"
" *\r\n"
" * This software is protected by copyright law and by international treaties. The source code, and all of its derivations,\r\n"
" * is provided by VoiceAge Corporation under the \"ITU-T Software Tools' General Public License\". Please, read the license file\r\n"
" * or refer to ITU-T Recommendation G.191 on \"SOFTWARE TOOLS FOR SPEECH AND AUDIO CODING STANDARDS\".\r\n"
" *\r\n"
" * Any use of this software is permitted provided that this notice is not removed and that neither the authors nor\r\n"
" * VoiceAge Corporation are deemed to have made any representations as to the suitability of this software\r\n"
" * for any purpose nor are held responsible for any defects of this software. THERE IS NO WARRANTY FOR THIS SOFTWARE.\r\n"
" *\r\n"
" * Authors: Guy Richard, Vladimir Malenovsky (Vladimir.Malenovsky@USherbrooke.ca)\r\n"
" */\r\n"
"\r\n"
"#ifndef WMOPS_H\r\n"
"#define WMOPS_H\r\n"
"\r\n"
"/* To Prevent \"warning: '$' in identifier or number\" message under GCC */\r\n"
"#ifdef __GNUC__\r\n"
"#pragma GCC system_header\r\n"
"#endif\r\n"
"\r\n"
"/* Real-time relationships */\r\n"
"#define FRAMES_PER_SECOND           50.0\r\n"
"#define MILLION_CYCLES              1e6\r\n"
"\r\n"
"#define WMOPS_BOOST_FAC             (1.0f)    /* scaling factor for equalizing the difference between automatic and manual instrumentation */\r\n"
"\r\n"
"#define FAC                         (FRAMES_PER_SECOND/(MILLION_CYCLES*WMOPS_BOOST_FAC))\r\n"
"\r\n"
"#define ENABLE_TREE                 0           /* Call tree may be activated by setting this flag to 1 */\r\n"
"#define NUM_INST                    20          /* Total number of instruction types (in enum below) */\r\n"
"\r\n"
"\r\n"
"/* inline function for memset in combination with float pointer */\r\n"
"#define SET_FLOAT(ptr,value,num)             \\\r\n"
"{                                            \\\r\n"
"   int i;                                    \\\r\n"
"                         LOOP(1); MOVE(num); \\\r\n"
"   for (i=0; i < num; i++)                   \\\r\n"
"   {                                         \\\r\n"
"      ptr[i] = value;                        \\\r\n"
"   }                                         \\\r\n"
"}\r\n"
"\r\n"
"/* inline function for memset in combination with integer */\r\n"
"#define SET_INT(ptr,value,num)               \\\r\n"
"{                                            \\\r\n"
"   int i;                                    \\\r\n"
"                         LOOP(1); MOVE(num); \\\r\n"
"   for (i=0; i < num; i++)                   \\\r\n"
"   {                                         \\\r\n"
"      ptr[i] = value;                        \\\r\n"
"   }                                         \\\r\n"
"}\r\n"
"\r\n"
"#ifdef WMOPS\r\n"
"enum instructions {_ADD,_ABS, _MULT, _MAC, _MOVE, _STORE, _LOGIC, _SHIFT, _BRANCH, _DIV, _SQRT, _TRANS, _FUNC, _LOOP, _INDIRECT, _PTR_INIT, _TEST, _POWER, _LOG, _MISC};\r\n"
"\r\n"
"#define _ADD_C      1\r\n"
"#define _ABS_C      1\r\n"
"#define _MULT_C     1\r\n"
"#define _MAC_C      1\r\n"
"#define _MOVE_C     1\r\n"
"#define _STORE_C    1\r\n"
"#define _LOGIC_C    1\r\n"
"#define _SHIFT_C    1\r\n"
"#define _BRANCH_C   4\r\n"
"#define _DIV_C     18\r\n"
"#define _SQRT_C    10\r\n"
"#define _TRANS_C   25\r\n"
"#define _FUNC_C     2  /* need to add number of arguments */\r\n"
"#define _LOOP_C     3\r\n"
"#define _INDIRECT_C 2\r\n"
"#define _PTR_INIT_C 1\r\n"
"#define _TEST_C     2\r\n"
"#define _POWER_C   25\r\n"
"#define _LOG_C     25\r\n"
"#define _MISC_C     1\r\n"
"\r\n"
"#define _ADD_P      1\r\n"
"#define _ABS_P      1\r\n"
"#define _MULT_P     1\r\n"
"#define _MAC_P      1\r\n"
"#define _MOVE_P     1\r\n"
"#define _STORE_P    0\r\n"
"#define _LOGIC_P    1\r\n"
"#define _SHIFT_P    1\r\n"
"#define _BRANCH_P   2\r\n"
"#define _DIV_P      2\r\n"
"#define _SQRT_P     2\r\n"
"#define _TRANS_P    2\r\n"
"#define _FUNC_P     2  /* need to add number of arguments */\r\n"
"#define _LOOP_P     1\r\n"
"#define _INDIRECT_P 2\r\n"
"#define _PTR_INIT_P 1\r\n"
"#define _TEST_P     1\r\n"
"#define _POWER_P    2\r\n"
"#define _LOG_P      2\r\n"
"#define _MISC_P     1\r\n"
"\r\n"
"#define ADD(x)      { {ops_cnt+=(_ADD_C*(x));      inst_cnt[_ADD]+=(x);      { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_ADD_P*(x));      }}}}\r\n"
"#define ABS(x)      { {ops_cnt+=(_ABS_C*(x));      inst_cnt[_ABS]+=(x);      { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_ABS_P*(x));      }}}}\r\n"
"#define MULT(x)     { {ops_cnt+=(_MULT_C*(x));     inst_cnt[_MULT]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_MULT_P*(x));     }}}}\r\n"
"#define MAC(x)      { {ops_cnt+=(_MAC_C*(x));      inst_cnt[_MAC]+=(x);      { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_MAC_P*(x));      }}}}\r\n"
"#define MOVE(x)     { {ops_cnt+=(_MOVE_C*(x));     inst_cnt[_MOVE]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_MOVE_P*(x));     }}}}\r\n"
"#define STORE(x)    { {ops_cnt+=(_STORE_C*(x));    inst_cnt[_STORE]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_STORE_P*(x));    }}}}\r\n"
"#define LOGIC(x)    { {ops_cnt+=(_LOGIC_C*(x));    inst_cnt[_LOGIC]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_LOGIC_P*(x));    }}}}\r\n"
"#define SHIFT(x)    { {ops_cnt+=(_SHIFT_C*(x));    inst_cnt[_SHIFT]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_SHIFT_P*(x));    }}}}\r\n"
"#define BRANCH(x)   { {ops_cnt+=(_BRANCH_C*(x));   inst_cnt[_BRANCH]+=(x);   { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_BRANCH_P*(x));   }}}}\r\n"
"#define DIV(x)      { {ops_cnt+=(_DIV_C*(x));      inst_cnt[_DIV]+=(x);      { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_DIV_P*(x));      }}}}\r\n"
"#define SQRT(x)     { {ops_cnt+=(_SQRT_C*(x));     inst_cnt[_SQRT]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_SQRT_P*(x));     }}}}\r\n"
"#define TRANS(x)    { {ops_cnt+=(_TRANS_C*(x));    inst_cnt[_TRANS]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_TRANS_P*(x));    }}}}\r\n"
"#define LOOP(x)     { {ops_cnt+=(_LOOP_C*(x));     inst_cnt[_LOOP]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_LOOP_P*(x));     }}}}\r\n"
"#define INDIRECT(x) { {ops_cnt+=(_INDIRECT_C*(x)); inst_cnt[_INDIRECT]+=(x); { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_INDIRECT_P*(x)); }}}}\r\n"
"#define PTR_INIT(x) { {ops_cnt+=(_PTR_INIT_C*(x)); inst_cnt[_PTR_INIT]+=(x); { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_PTR_INIT_P*(x)); }}}}\r\n"
"#define TEST(x)     { {ops_cnt+=(_TEST_C*(x));     inst_cnt[_TEST]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_TEST_P*(x));     }}}}\r\n"
"#define POWER(x)    { {ops_cnt+=(_POWER_C*(x));    inst_cnt[_POWER]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_POWER_P*(x));    }}}}\r\n"
"#define LOG(x)      { {ops_cnt+=(_LOG_C*(x));      inst_cnt[_LOG]+=(x);      { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_LOG_P*(x));      }}}}\r\n"
"#define MISC(x)     { {ops_cnt+=(_MISC_C*(x));     inst_cnt[_MISC]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_MISC_P*(x));     }}}}\r\n"
"\r\n"
"#define FUNC(x)     { {ops_cnt+=(_FUNC_C+_MOVE_C*(x)); inst_cnt[_FUNC]++; inst_cnt[_MOVE]+=(x); { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_FUNC_P+_MOVE_P*(x)); }}}}\r\n"
"\r\n"
"#define DADD(x)     { {ops_cnt+=(2*_ADD_C*(x));    inst_cnt[_ADD]+=(x);      { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_ADD_P*(x));      }}}}\r\n"
"#define DMULT(x)    { {ops_cnt+=(2*_MULT_C*(x));   inst_cnt[_MULT]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_MULT_P*(x));     }}}}\r\n"
"#define DMAC(x)     { {ops_cnt+=(2*_MAC_C*(x));    inst_cnt[_MAC]+=(x);      { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_MAC_P*(x));      }}}}\r\n"
"#define DMOVE(x)    { {ops_cnt+=(2*_MOVE_C*(x));   inst_cnt[_MOVE]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_MOVE_P*(x));     }}}}\r\n"
"#define DSTORE(x)   { {ops_cnt+=(2*_STORE_C*(x));  inst_cnt[_STORE]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_STORE_P*(x));    }}}}\r\n"
"#define DLOGIC(x)   { {ops_cnt+=(2*_LOGIC_C*(x));  inst_cnt[_LOGIC]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_LOGIC_P*(x));    }}}}\r\n"
"#define DSHIFT(x)   { {ops_cnt+=(2*_SHIFT_C*(x));  inst_cnt[_SHIFT]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_SHIFT_P*(x));    }}}}\r\n"
"#define DDIV(x)     { {ops_cnt+=(2*_DIV_C*(x));    inst_cnt[_DIV]+=(x);      { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_DIV_P*(x));      }}}}\r\n"
"#define DSQRT(x)    { {ops_cnt+=(2*_SQRT_C*(x));   inst_cnt[_SQRT]+=(x);     { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_SQRT_P*(x));     }}}}\r\n"
"#define DTRANS(x)   { {ops_cnt+=(2*_TRANS_C*(x));  inst_cnt[_TRANS]+=(x);    { static int pcnt; if (!pcnt) { pcnt=1; prom_cnt+=(_TRANS_P*(x));    }}}}\r\n"
"\r\n"
"extern double ops_cnt;\r\n"
"extern double prom_cnt;\r\n"
"extern double inst_cnt [NUM_INST];\r\n"
"extern int ops_cnt_activ;\r\n"
"\r\n"
"void reset_wmops (void);\r\n"
"void push_wmops (const char *label);\r\n"
"void pop_wmops (void);\r\n"
"void update_wmops (void);\r\n"
"void print_wmops (void);\r\n"
"\r\n"
"#else /* WMOPS counting disabled */\r\n"
"\r\n"
"#define reset_wmops()\r\n"
"extern int cntr_push_pop;\r\n"
"#define push_wmops(x) (cntr_push_pop++)\r\n"
"#define pop_wmops() (cntr_push_pop--)\r\n"
"#define update_wmops() (assert(cntr_push_pop == 0))\r\n"
"#define print_wmops()\r\n"
"\r\n"
"#define ADD(x)\r\n"
"#define ABS(x)\r\n"
"#define MULT(x)\r\n"
"#define MAC(x)\r\n"
"#define MOVE(x)\r\n"
"#define STORE(x)\r\n"
"#define LOGIC(x)\r\n"
"#define SHIFT(x)\r\n"
"#define BRANCH(x)\r\n"
"#define DIV(x)\r\n"
"#define SQRT(x)\r\n"
"#define TRANS(x)\r\n"
"#define FUNC(x)\r\n"
"#define LOOP(x)\r\n"
"#define INDIRECT(x)\r\n"
"#define PTR_INIT(x)\r\n"
"#define TEST(x)         \r\n"
"#define POWER(x)        \r\n"
"#define LOG(x)          \r\n"
"#define MISC(x)         \r\n"
"\r\n"
"#define DADD(x)\r\n"
"#define DMULT(x)\r\n"
"#define DMAC(x)\r\n"
"#define DMOVE(x)\r\n"
"#define DSTORE(x)\r\n"
"#define DLOGIC(x)\r\n"
"#define DSHIFT(x)\r\n"
"#define DDIV(x)\r\n"
"#define DSQRT(x)\r\n"
"#define DTRANS(x)\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"/* mac & msu (Non Instrumented Versions) */\r\n"
"#ifndef mac\r\n"
"#define mac(a, b, c) ((a)+(b)*(c))\r\n"
"#endif\r\n"
"#ifndef mac\r\n"
"#define msu(a, b, c) ((a)-(b)*(c))\r\n"
"#endif\r\n"
"\r\n"
"#ifndef WMOPS\r\n"
"/* DESACTIVATE the Counting Mechanism */\r\n"
"#define OP_COUNT_(op, n)\r\n"
"\r\n"
"/* DESACTIVATE Operation Counter Wrappers */\r\n"
"#define OP_COUNT_WRAPPER1_(op, val)  (val)\r\n"
"#define OP_COUNT_WRAPPER2_(expr)\r\n"
"#define OP_COUNT_WRAPPER3_(op, expr) expr\r\n"
"\r\n"
"/* DESACTIVATE Logical & Ternary Operators */\r\n"
"#define __\r\n"
"#define _\r\n"
"\r\n"
"#else\r\n"
"\r\n"
"/* '*ops_cnt_ptr' is Used to Avoid: \"warning: operation on 'ops_cnt' may be undefined\" with Cygwin gcc Compiler */\r\n"
"static double* ops_cnt_ptr = &ops_cnt;\r\n"
"#define OP_COUNT_(op, x) (*ops_cnt_ptr+=(op##_C*(x)), inst_cnt[op]+=(x))\r\n"
"\r\n"
"/* #pragma GCC diagnostic is Available from gcc V4.2.4 */\r\n"
"#if (__GNUC__*10000 + __GNUC_MINOR__*100 + __GNUC_PATCHLEVEL__) >= 40204\r\n"
"/* Disable Some Warnings with Cygwin gcc Compiler (Only when WMOPS are Activated) */\r\n"
"/* To Avoid: \"warning: suggest parentheses around && within ||\" and\r\n"
"             \"warning: suggest explicit braces to avoid ambiguous else\" */\r\n"
"#pragma GCC diagnostic ignored \"-Wparentheses\" /* Otherwise use : \"-Wno-parentheses\" */\r\n"
"#endif\r\n"
"\r\n"
"/******************************************************************/\r\n"
"/* NOTES:                                                         */\r\n"
"/*   The 'wmc_flag_' flag is global to avoid declaration in every */\r\n"
"/*   function and 'static' to avoid clashing with other modules   */\r\n"
"/*   that include this header file.                               */\r\n"
"/*                                                                */\r\n"
"/*   The declarations of 'wmc_flag_' and 'wops_' in this header   */\r\n"
"/*   file prevent the addition of a 'C' file to the Project.      */\r\n"
"/******************************************************************/\r\n"
"\r\n"
"/* General Purpose Global Flag */\r\n"
"static int wmc_flag_ = 0;\r\n"
"\r\n"
"/* Operation Counter Wrappers */\r\n"
"#define OP_COUNT_WRAPPER1_(op, val)  (op, val)\r\n"
"#define OP_COUNT_WRAPPER2_(expr)     if (expr, 0); else\r\n"
"#define OP_COUNT_WRAPPER3_(op, expr) if ( op , 0); else expr\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"/* Define all Macros without '{' & '}' (None of these should be called externally!) */\r\n"
"#define ABS_(x)      OP_COUNT_(_ABS,      (x)*WMOPS_BOOST_FAC)\r\n"
"#define ADD_(x)      OP_COUNT_(_ADD,      (x)*WMOPS_BOOST_FAC)\r\n"
"#define MULT_(x)     OP_COUNT_(_MULT,     (x)*WMOPS_BOOST_FAC)\r\n"
"#define MAC_(x)      OP_COUNT_(_MAC,      (x)*WMOPS_BOOST_FAC)\r\n"
"#define MOVE_(x)     OP_COUNT_(_MOVE,     (x)*WMOPS_BOOST_FAC)\r\n"
"#define STORE_(x)    OP_COUNT_(_STORE,    (x)*WMOPS_BOOST_FAC)\r\n"
"#define LOGIC_(x)    OP_COUNT_(_LOGIC,    (x)*WMOPS_BOOST_FAC)\r\n"
"#define SHIFT_(x)    OP_COUNT_(_SHIFT,    (x)*WMOPS_BOOST_FAC)\r\n"
"#define BRANCH_(x)   OP_COUNT_(_BRANCH,   (x)*WMOPS_BOOST_FAC)\r\n"
"#define DIV_(x)      OP_COUNT_(_DIV,      (x)*WMOPS_BOOST_FAC)\r\n"
"#define SQRT_(x)     OP_COUNT_(_SQRT,     (x)*WMOPS_BOOST_FAC)\r\n"
"#define TRANS_(x)    OP_COUNT_(_TRANS,    (x)*WMOPS_BOOST_FAC)\r\n"
"#define POWER_(x)    TRANS_(x)\r\n"
"#define LOG_(x)      TRANS_(x)\r\n"
"#define LOOP_(x)     OP_COUNT_(_LOOP,     (x)*WMOPS_BOOST_FAC)\r\n"
"#define INDIRECT_(x) OP_COUNT_(_INDIRECT, (x)*WMOPS_BOOST_FAC)\r\n"
"#define PTR_INIT_(x) OP_COUNT_(_PTR_INIT, (x)*WMOPS_BOOST_FAC)\r\n"
"#define FUNC_(x)     (OP_COUNT_(_MOVE,    (x)*WMOPS_BOOST_FAC), OP_COUNT_(_FUNC, 1))\r\n"
"#define MISC_(x)     ABS_(x)\r\n"
"\r\n"
"/* Math Operations */\r\n"
"#define   abs_ OP_COUNT_WRAPPER1_(  ABS_(1),   abs)\r\n"
"#define  fabs_ OP_COUNT_WRAPPER1_(  ABS_(1),  fabs)\r\n"
"#define  labs_ OP_COUNT_WRAPPER1_(  ABS_(1),  labs)\r\n"
"#define floor_ OP_COUNT_WRAPPER1_( MISC_(1), floor)\r\n"
"#define  sqrt_ OP_COUNT_WRAPPER1_( SQRT_(1),  sqrt)\r\n"
"#define   pow_ OP_COUNT_WRAPPER1_(POWER_(1),   pow)\r\n"
"#define   exp_ OP_COUNT_WRAPPER1_(POWER_(1),   exp)\r\n"
"#define   log_ OP_COUNT_WRAPPER1_(  LOG_(1),   log)\r\n"
"#define log10_ OP_COUNT_WRAPPER1_(  LOG_(1), log10)\r\n"
"#define   cos_ OP_COUNT_WRAPPER1_(TRANS_(1),   cos)\r\n"
"#define   sin_ OP_COUNT_WRAPPER1_(TRANS_(1),   sin)\r\n"
"#define   tan_ OP_COUNT_WRAPPER1_(TRANS_(1),   tan)\r\n"
"#define  acos_ OP_COUNT_WRAPPER1_(TRANS_(1),  acos)\r\n"
"#define  asin_ OP_COUNT_WRAPPER1_(TRANS_(1),  asin)\r\n"
"#define  atan_ OP_COUNT_WRAPPER1_(TRANS_(1),  atan)\r\n"
"#define atan2_ OP_COUNT_WRAPPER1_(TRANS_(1), atan2)\r\n"
"#define  cosh_ OP_COUNT_WRAPPER1_(TRANS_(1),  cosh)\r\n"
"#define  sinh_ OP_COUNT_WRAPPER1_(TRANS_(1),  sinh)\r\n"
"#define  tanh_ OP_COUNT_WRAPPER1_(TRANS_(1),  tanh)\r\n"
"#define  fmod_ OP_COUNT_WRAPPER1_(  DIV_(1),  fmod)\r\n"
"/* these macros use any local macros already defined */\r\n"
"/* min/max and their Variants */\r\n"
"#define min_(a, b) OP_COUNT_WRAPPER1_(MISC_(1), min((a),(b)))\r\n"
"#define max_(a, b) OP_COUNT_WRAPPER1_(MISC_(1), max((a),(b)))\r\n"
"#define MIN_(a, b) OP_COUNT_WRAPPER1_(MISC_(1), MIN((a),(b)))\r\n"
"#define MAX_(a, b) OP_COUNT_WRAPPER1_(MISC_(1), MAX((a),(b)))\r\n"
"#define Min_(a, b) OP_COUNT_WRAPPER1_(MISC_(1), Min((a),(b)))\r\n"
"#define Max_(a, b) OP_COUNT_WRAPPER1_(MISC_(1), Max((a),(b)))\r\n"
"/* Square and its Variants */\r\n"
"#define    sqr_(x) OP_COUNT_WRAPPER1_(MULT_(1),   sqr((x)))\r\n"
"#define    Sqr_(x) OP_COUNT_WRAPPER1_(MULT_(1),   Sqr((x)))\r\n"
"#define    SQR_(x) OP_COUNT_WRAPPER1_(MULT_(1),   SQR((x)))\r\n"
"#define square_(x) OP_COUNT_WRAPPER1_(MULT_(1),square((x)))\r\n"
"#define Square_(x) OP_COUNT_WRAPPER1_(MULT_(1),Square((x)))\r\n"
"#define SQUARE_(x) OP_COUNT_WRAPPER1_(MULT_(1),SQUARE((x)))\r\n"
"/* Sign and its Variants */\r\n"
"#define   sign_(x) OP_COUNT_WRAPPER1_(MOVE_(1),  sign((x)))\r\n"
"#define   Sign_(x) OP_COUNT_WRAPPER1_(MOVE_(1),  Sign((x)))\r\n"
"#define   SIGN_(x) OP_COUNT_WRAPPER1_(MOVE_(1),  SIGN((x)))\r\n"
"/* Square Root and its Variants */\r\n"
"#define  sqrtf_(x) OP_COUNT_WRAPPER1_(SQRT_(1), sqrtf((x)))\r\n"
"/* Invert Square Root and its Variants */\r\n"
"#define inv_sqrt_(x) OP_COUNT_WRAPPER1_(SQRT_(1), inv_sqrt((x)))\r\n"
"/* Others */\r\n"
"#define log_base_2_(x) OP_COUNT_WRAPPER1_(( LOG_(1),MULT_(1)), log_base_2((x)))\r\n"
"#define     log2_f_(x) OP_COUNT_WRAPPER1_(( LOG_(1),MULT_(1)),     log2_f((x)))\r\n"
"/* The 'wmc_flag_=wmc_flag_' is Used to Avoid: \"warning: left-hand operand of comma expression has no effect\"\r\n"
"   with Cygwin gcc Compiler */\r\n"
"#define     _round_(x) OP_COUNT_WRAPPER1_(wmc_flag_=wmc_flag_,     _round((x)))\r\n"
"#define    round_f_(x) OP_COUNT_WRAPPER1_(wmc_flag_=wmc_flag_,    round_f((x)))\r\n"
"#define    _squant_(x) OP_COUNT_WRAPPER1_(wmc_flag_=wmc_flag_,    _squant((x)))\r\n"
"/* Set Min/Max */\r\n"
"#define set_min_(a, b) OP_COUNT_WRAPPER3_((ADD_(1),BRANCH_(1),MOVE_(1)), set_min((a),(b)))\r\n"
"#define set_max_(a, b) OP_COUNT_WRAPPER3_((ADD_(1),BRANCH_(1),MOVE_(1)), set_max((a),(b)))\r\n"
"/* mac & msu (Instrumented Versions) */\r\n"
"#define  mac_(a, b, c) OP_COUNT_WRAPPER1_(MAC_(1), mac(a, b, c))\r\n"
"#define  msu_(a, b, c) OP_COUNT_WRAPPER1_(MAC_(1), msu(a, b, c))\r\n"
"\r\n"
"/* Functions */\r\n"
"#define func_(name, x) OP_COUNT_WRAPPER1_(FUNC_(x), name)\r\n"
"\r\n"
"/* Logical Operators */\r\n"
"#ifndef __\r\n"
"#define __ (BRANCH_(1), 1) &&\r\n"
"#endif\r\n"
"\r\n"
"/* Ternary Operators (? and :) */\r\n"
"#ifndef _\r\n"
"#define _ (BRANCH_(1), 0)?0:\r\n"
"#endif\r\n"
"\r\n"
"/* Flow Control keywords */\r\n"
"#define       if_    OP_COUNT_WRAPPER2_(BRANCH_(1)) if\r\n"
"#define      for_    OP_COUNT_WRAPPER2_(  LOOP_(1)) for\r\n"
"#define    while_(c) while OP_COUNT_WRAPPER1_(BRANCH_(1), (c)) /* needs extra \"()\" if ',' encountered */\r\n"
"#define       do_    do {\r\n"
"#define   _while     BRANCH_(1);} while\r\n"
"\r\n"
"#define     goto_    OP_COUNT_WRAPPER2_(BRANCH_(1)) goto\r\n"
"#define    break_    OP_COUNT_WRAPPER2_(BRANCH_(1)) break\r\n"
"#define continue_    OP_COUNT_WRAPPER2_(BRANCH_(1)) continue\r\n"
"#define   return_    OP_COUNT_WRAPPER2_((wmc_flag_=stack_tree_level_, STACK_DEPTH_FCT_RETURN)) return\r\n"
"\r\n"
"#define   switch_    OP_COUNT_WRAPPER2_((BRANCH_(1),wmc_flag_=1)) switch\r\n"
"#define     cost_(n) OP_COUNT_WRAPPER2_(wmc_flag_?(ADD_(n),BRANCH_(n),wmc_flag_=0):0);\r\n"
"\r\n"
"#ifdef WMOPS\r\n"
"\r\n"
"/* Check if EOF is defined */\r\n"
"#ifndef EOF          \r\n"
"#include <stdio.h> /* required for 'fprintf' */\r\n"
"#endif\r\n"
"\r\n"
"/* Counter Function (should not be called externally!) */\r\n"
"static void wops_(const char* ops)\r\n"
"{\r\n"
"    char lm = 0;        /* lm: Last Operation is Math */\r\n"
"    static char lo = 0; /* Last Operation */\r\n"
"#define ACC 2\r\n"
"#define MUL 1\r\n"
"    void (*fct)(const char* ops) = wops_;\r\n"
"st: while (*ops != '\\0') {\r\n"
"    switch (*ops++) {\r\n"
"        int cnt;\r\n"
"    case '-':          for (cnt = 0; ops[cnt] == '>'; cnt++); if (cnt & 1) goto ind;\r\n"
"    case '+':                     lm = 2; if (lo & MUL) { MULT_(-1); MAC_(1); break; }\r\n"
"    lo = ACC << 2; case 'U': case 'D':     ADD_(1); break;\r\n"
"    case '*':                     lm = 2; if (lo & ACC) { ADD_(-1); MAC_(1); break; }\r\n"
"            lo = MUL << 2;                        MULT_(1); break;\r\n"
"    case '/': case '%':           lm = 2;                         DIV_(1); break;\r\n"
"    case '&': case '|': case '^': lm = 2; case '~':             LOGIC_(1); break;\r\n"
"    case '<': case '>':                        if (*ops != ops[-1]) goto error; ops++;\r\n"
"    case -85: case -69:           lm = 2;                       SHIFT_(1); break;\r\n"
"    case 'L': case 'G':                                 if (*ops == 't') goto comp;\r\n"
"    case 'E': case 'N':                                 if (*ops != 'e') goto error;\r\n"
"    comp:                                                            ops++; ADD_(1); break;\r\n"
"    case '!':                                                  MISC_(2); break;\r\n"
"    case 'M':                                                  MOVE_(1); break;\r\n"
"    case 'S':                                                 STORE_(1); break;\r\n"
"    case 'P':                                              PTR_INIT_(1); break;\r\n"
"    case '[': case ']':                                                  goto st;\r\n"
"    ind:                                                                      ops++;\r\n"
"    case 'I': case '.':                                    INDIRECT_(1); break;\r\n"
"    case '=':                                                    if (lm) goto st;\r\n"
"    case '\\0': /* This Cannot Happen */\r\n"
"        /* These are Used to Avoid: \"warning: 'name' defined but not used\"\r\n"
"           with Cygwin gcc Compiler */\r\n"
"        wmc_flag_ = wmc_flag_;\r\n"
"        ops_cnt_ptr = ops_cnt_ptr;\r\n"
"        fct(\"\");\r\n"
"    error:      default:\r\n"
"        /* The Following Checks are made instead of Including the Required Files to\r\n"
"           avoid generating warnings if they are already Included in the Source File */\r\n"
"#ifdef EOF      /* Will exist if <stdio.h> is Included */\r\n"
"        fprintf(stderr, \"\\r wops: Invalid Counting Operation '%s'\\n\", ops - 1);\r\n"
"#ifdef EXIT_FAILURE /* Will exist if <stdlib.h> is Included */\r\n"
"        exit(EXIT_FAILURE);\r\n"
"#endif\r\n"
"#endif\r\n"
"        return; /* If no Exit Mechanism, just continue */\r\n"
"    } lm >>= 1; lo >>= 2;\r\n"
"}\r\n"
"}\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"/* All Other Operations */\r\n"
"#define $(str) OP_COUNT_WRAPPER2_(wops_(str))\r\n"
"\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * Memory counting tool\r\n"
" *-------------------------------------------------------------------*/\r\n"
"\r\n"
"/* Enhanced Const Data Size Counting (Rounding Up to the Nearest 'Integer' Size) */\r\n"
"#define rsize(item) ((sizeof(item) + sizeof(int) - 1) / sizeof(int) * sizeof(int))\r\n"
"\r\n"
"#ifdef _MSC_VER\r\n"
"/* Disable \"warning C4210: nonstandard extension used : function given file scope\" with Visual Studio Compiler */\r\n"
"#pragma warning(disable: 4210)\r\n"
"#endif\r\n"
"\r\n"
"/* Const Data Size and PROM Size Wrapper Functions */\r\n"
"#define Const_Data_Size_Func(file) Const_Data_Size_##file(void)\r\n"
"#define Get_Const_Data_Size(file, val_ptr) { extern int Const_Data_Size_##file(void); *(val_ptr) = Const_Data_Size_##file(); }\r\n"
"#define PROM_Size_Func(file) PROM_Size_##file(void)\r\n"
"#define Get_PROM_Size(file, val_ptr) { int PROM_Size_##file(void); *(val_ptr) = PROM_Size_##file(); }\r\n"
"\r\n"
"/* ROM Size Lookup Table - contains information about PROM size and Const Data Size in all source files */\r\n"
"/* The print_mem() function looks for this table to print the results of Const Data usage and PROM usage */\r\n"
"typedef struct ROM_Size_Lookup_Table\r\n"
"{\r\n"
"    const char file_spec[255];\r\n"
"    int PROM_size;\r\n"
"    int (*Get_Const_Data_Size_Func) (void);\r\n"
"} ROM_Size_Lookup_Table;\r\n"
"\r\n"
"/* The WMC tool inserts the following declaration during the innstrumentation process in the .c file where the function print_mem() is located */\r\n"
"/* and modifies it to print_mem(Const_Data_PROM_Table) */\r\n"
"\r\n"
"/* #ifdef WMOPS\r\n"
" * ROM_Size_Lookup_Table Const_Data_PROM_Table[] =\r\n"
" * {\r\n"
" *   {\"../lib_enc/rom_enc.c\", 0, NULL},\r\n"
" *   {\"../lib_com/*.c\", 0, NULL},\r\n"
" *   {\"\", -1, NULL}\r\n"
" * };\r\n"
" * #endif\r\n"
" */\r\n"
"\r\n"
"/*#define MEM_ALIGN_64BITS */ /* Define this when using 64 Bits values in the code (ex: double), otherwise it will align on 32 Bits */\r\n"
"/*#define MEM_COUNT_DETAILS*/\r\n"
"\r\n"
"typedef enum\r\n"
"{\r\n"
"    USE_BYTES = 0,\r\n"
"    USE_16BITS = 1,\r\n"
"    USE_32BITS = 2\r\n"
"} Counting_Size;\r\n"
"\r\n"
"#if ( defined( _WIN32 ) && ( _MSC_VER <= 1800 ) && ( _MSC_VER >= 1300 ) )\r\n"
"#define __func__ __FUNCTION__\r\n"
"#elif defined( __STDC_VERSION__ ) && __STDC_VERSION__ < 199901L\r\n"
"#if ( __GNUC__ >= 2 )\r\n"
"#define __func__ __FUNCTION__\r\n"
"#else\r\n"
"#define __func__ \"<unknown>\"\r\n"
"#endif\r\n"
"#elif defined( __GNUC__ )\r\n"
"#define __func__ __extension__ __FUNCTION__\r\n"
"#endif\r\n"
"\r\n"
"\r\n"
"#ifdef WMOPS\r\n"
"\r\n"
"void* mem_alloc(const char* func_name, int func_lineno, size_t size, char* alloc_str);\r\n"
"void mem_free(const char* func_name, int func_lineno, void* ptr);\r\n"
"\r\n"
"#define malloc_(size)          mem_alloc( __func__, __LINE__, size, \"m:\" #size )\r\n"
"#define calloc_(n,size)        mem_alloc( __func__, __LINE__, ( n ) * ( size ), \"c:\" #n \", \" #size )\r\n"
"#define free_(ptr)             mem_free( __func__, __LINE__, ptr )\r\n"
"\r\n"
"void reset_mem(Counting_Size cnt_size);\r\n"
"void print_mem(ROM_Size_Lookup_Table Const_Data_PROM_Table[]);\r\n"
"\r\n"
"int push_stack(const char* filename, const char* fctname);\r\n"
"int pop_stack(const char* filename, const char* fctname);\r\n"
"\r\n"
"#ifdef WMOPS_DETAIL\r\n"
"#define STACK_DEPTH_FCT_CALL (push_wmops(__FUNCTION__), push_stack(__FILE__,__FUNCTION__)) /* add push_wmops() in all function calls */\r\n"
"#define STACK_DEPTH_FCT_RETURN (pop_wmops(), pop_stack(__FILE__,__FUNCTION__))              /* add pop_wmops() in all function returns */\r\n"
"#else\r\n"
"#define STACK_DEPTH_FCT_CALL push_stack(__FILE__,__FUNCTION__)  \r\n"
"#define STACK_DEPTH_FCT_RETURN pop_stack(__FILE__,__FUNCTION__) \r\n"
"#endif\r\n"
"\r\n"
"void reset_stack(void);\r\n"
"#define func_start_ int stack_tree_level_=STACK_DEPTH_FCT_CALL;\r\n"
"\r\n"
"#else\r\n"
"#define malloc_(n1)            malloc( n1 )\r\n"
"#define calloc_(n1,n2)         calloc( n1, n2 )\r\n"
"#define free_(ptr)             free( ptr )\r\n"
"#define reset_mem( cnt_size )\r\n"
"#define print_mem( Const_Data_PROM_Table )\r\n"
"\r\n"
"#define push_stack(file,fct)\r\n"
"#define pop_stack(file,fct)\r\n"
"#define reset_stack()\r\n"
"#define func_start_\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"#endif /* WMOPS_H */\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"