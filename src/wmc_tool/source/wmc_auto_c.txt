"/*\r\n"
" * (C) 2022 copyright VoiceAge Corporation. All Rights Reserved.\r\n"
" *\r\n"
" * This software is protected by copyright law and by international treaties. The source code, and all of its derivations,\r\n"
" * is provided by VoiceAge Corporation under the \"ITU-T Software Tools' General Public License\". Please, read the license file\r\n"
" * or refer to ITU-T Recommendation G.191 on \"SOFTWARE TOOLS FOR SPEECH AND AUDIO CODING STANDARDS\".\r\n"
" *\r\n"
" * Any use of this software is permitted provided that this notice is not removed and that neither the authors nor\r\n"
" * VoiceAge Corporation are deemed to have made any representations as to the suitability of this software\r\n"
" * for any purpose nor are held responsible for any defects of this software. THERE IS NO WARRANTY FOR THIS SOFTWARE.\r\n"
" *\r\n"
" * Authors: Guy Richard, Vladimir Malenovsky (Vladimir.Malenovsky@USherbrooke.ca)\r\n"
" */\r\n"
"\r\n"
"#include <stdio.h>\r\n"
"#include <stdlib.h>\r\n"
"#include <string.h>\r\n"
"#include <stdint.h>\r\n"
"#include <sys/stat.h>\r\n"
"\r\n"
"#ifndef _MSC_VER\r\n"
"#include <dirent.h>\r\n"
"#include <errno.h>\r\n"
"#else\r\n"
" #include <windows.h>\r\n"
"#endif\r\n"
"\r\n"
"#include \"options.h\"\r\n"
"#include \"wmc_auto.h\"\r\n"
"\r\n"
"  \r\n"
"/*-------------------------------------------------------------------*\r\n"
" * WMOPS counting tool\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"#ifdef WMOPS\r\n"
"\r\n"
"#define WMC_TOOL_SKIP      /* Skip the instrumentation of this file, if invoked by accident */\r\n"
"\r\n"
"#define MAX_RECORDS     1024\r\n"
"#define MAX_CHAR        64\r\n"
"#define MAX_STACK       64\r\n"
"#define DOUBLE_MAX      0x80000000\r\n"
"\r\n"
"struct wmops_record\r\n"
"{\r\n"
"  char   label[MAX_CHAR];\r\n"
"  long   call_number;\r\n"
"  long   update_cnt;                 \r\n"
"  int    call_tree[MAX_RECORDS];\r\n"
"  double start_selfcnt;\r\n"
"  double current_selfcnt;\r\n"
"  double max_selfcnt;\r\n"
"  double min_selfcnt;\r\n"
"  double tot_selfcnt;\r\n"
"  double start_cnt;     /* The following take into account the decendants */\r\n"
"  double current_cnt;\r\n"
"  double max_cnt;\r\n"
"  double min_cnt;\r\n"
"  double tot_cnt;\r\n"
"};\r\n"
"\r\n"
"double ops_cnt; \r\n"
"double prom_cnt; \r\n"
"double inst_cnt[NUM_INST];\r\n"
"\r\n"
"static struct wmops_record wmops[MAX_RECORDS];\r\n"
"static int stack[MAX_STACK];\r\n"
"static int sptr;\r\n"
"static int num_records;\r\n"
"static int current_record;\r\n"
"static long update_cnt;\r\n"
"static double start_cnt;\r\n"
"static double max_cnt;\r\n"
"static double min_cnt;\r\n"
"static double inst_cnt_wc[NUM_INST];\r\n"
"static long fnum_cnt_wc; \r\n"
"\r\n"
"\r\n"
"void reset_wmops (void)\r\n"
"{\r\n"
"  int i, j;\r\n"
"\r\n"
"  for (i = 0; i < MAX_RECORDS; i++)\r\n"
"  {\r\n"
"    strcpy(&wmops[i].label[0], \"\\0\");\r\n"
"    wmops[i].call_number = 0;\r\n"
"    wmops[i].update_cnt = 0;           \r\n"
"    for (j = 0; j < MAX_RECORDS; j++)\r\n"
"    {\r\n"
"      wmops[i].call_tree[j] = -1;\r\n"
"    }\r\n"
"    wmops[i].start_selfcnt = 0.0;\r\n"
"    wmops[i].current_selfcnt = 0.0;\r\n"
"    wmops[i].max_selfcnt = 0.0;\r\n"
"    wmops[i].min_selfcnt = DOUBLE_MAX;\r\n"
"    wmops[i].tot_selfcnt = 0.0;\r\n"
"    wmops[i].start_cnt = 0.0;\r\n"
"    wmops[i].current_cnt = 0.0;\r\n"
"    wmops[i].max_cnt = 0.0;\r\n"
"    wmops[i].min_cnt = DOUBLE_MAX;\r\n"
"    wmops[i].tot_cnt = 0.0;\r\n"
"  }\r\n"
"\r\n"
"  for (i = 0; i < MAX_STACK; i++)\r\n"
"  {\r\n"
"    stack[i] = -1;\r\n"
"  }\r\n"
"  sptr = 0;\r\n"
"  num_records = 0;\r\n"
"  current_record = -1;\r\n"
"  update_cnt = 0;\r\n"
"\r\n"
"  max_cnt = 0.0;\r\n"
"  min_cnt = DOUBLE_MAX;\r\n"
"  start_cnt = 0.0;\r\n"
"  ops_cnt = 0.0;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void push_wmops (const char *label)\r\n"
"{\r\n"
"  int new_flag;\r\n"
"  int i, j;\r\n"
"\r\n"
"  /* Check if new function record label */\r\n"
"  new_flag = 1;\r\n"
"  for (i = 0; i < num_records; i++)\r\n"
"  {\r\n"
"      if (strcmp(wmops[i].label, label) == 0)\r\n"
"      {\r\n"
"          new_flag = 0;\r\n"
"          break;\r\n"
"      }\r\n"
"  }\r\n"
"\r\n"
"  /* Configure new record */\r\n"
"  if (new_flag)\r\n"
"  {\r\n"
"      if (num_records >= MAX_RECORDS)\r\n"
"      {\r\n"
"          fprintf(stdout, \"push_wmops(): exceeded MAX_RECORDS count.\\n\\n\");\r\n"
"          exit(-1);\r\n"
"      }\r\n"
"      strcpy(wmops[i].label, label);\r\n"
"      num_records++;\r\n"
"  }\r\n"
"\r\n"
"  /* Push current context onto stack */\r\n"
"  if (current_record >= 0)\r\n"
"  {\r\n"
"      if (sptr >= MAX_STACK)\r\n"
"      {\r\n"
"          fprintf(stdout, \"\\r push_wmops(): stack exceeded, try inreasing MAX_STACK\\n\");\r\n"
"          exit(-1);\r\n"
"      }\r\n"
"      stack[sptr++] = current_record;\r\n"
"\r\n"
"      /* accumulate op counts */\r\n"
"      wmops[current_record].current_selfcnt += ops_cnt - wmops[current_record].start_selfcnt;\r\n"
"\r\n"
"      /* update call tree */\r\n"
"      for (j = 0; j < MAX_RECORDS; j++)\r\n"
"      {\r\n"
"          if (wmops[i].call_tree[j] == current_record)\r\n"
"          {\r\n"
"              break;\r\n"
"          }\r\n"
"          else if (wmops[i].call_tree[j] == -1)\r\n"
"          {\r\n"
"              wmops[i].call_tree[j] = current_record;\r\n"
"              break;\r\n"
"          }\r\n"
"      }\r\n"
"  }\r\n"
"\r\n"
"  /* init current record */\r\n"
"  current_record = i;\r\n"
"  wmops[current_record].start_selfcnt = ops_cnt;\r\n"
"  wmops[current_record].start_cnt = ops_cnt;\r\n"
"  wmops[current_record].call_number++;\r\n"
"\r\n"
"  return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void pop_wmops (void)\r\n"
"{\r\n"
"\r\n"
"  /* Check for underflow */\r\n"
"  if (current_record < 0)\r\n"
"  {\r\n"
"     fprintf (stdout, \"\\r pop_wmops(): stack underflow, too many calls to pop_wmops()\\n\");\r\n"
"     exit (-1);\r\n"
"  }\r\n"
"\r\n"
"  /* update count of current record */\r\n"
"  wmops[current_record].current_selfcnt += ops_cnt - wmops[current_record].start_selfcnt;\r\n"
"  wmops[current_record].current_cnt += ops_cnt - wmops[current_record].start_cnt;\r\n"
"\r\n"
"  /* Get back previous context from stack */\r\n"
"  if (sptr > 0)\r\n"
"  {\r\n"
"     current_record = stack[--sptr];\r\n"
"     wmops[current_record].start_selfcnt = ops_cnt;\r\n"
"  }\r\n"
"  else\r\n"
"  {\r\n"
"     current_record = -1;\r\n"
"  }\r\n"
"\r\n"
"  return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void update_wmops (void)\r\n"
"{\r\n"
"  int i;\r\n"
"  double current_cnt;\r\n"
"\r\n"
"  if ( sptr != 0 )\r\n"
"  {\r\n"
"      fprintf (stdout, \"update_wmops(): Stack must be empty!\\n\");\r\n"
"      exit (-1);\r\n"
"  }\r\n"
"\r\n"
"  for (i = 0; i < num_records; i++)\r\n"
"  {\r\n"
"      wmops[i].tot_selfcnt += wmops[i].current_selfcnt;\r\n"
"      wmops[i].tot_cnt += wmops[i].current_cnt;\r\n"
"\r\n"
"      if (wmops[i].current_selfcnt > 0)\r\n"
"      {\r\n"
"          if (wmops[i].current_selfcnt > wmops[i].max_selfcnt)\r\n"
"          {\r\n"
"              wmops[i].max_selfcnt = wmops[i].current_selfcnt;\r\n"
"          }\r\n"
"\r\n"
"          if (wmops[i].current_selfcnt < wmops[i].min_selfcnt)\r\n"
"          {\r\n"
"              wmops[i].min_selfcnt = wmops[i].current_selfcnt;\r\n"
"          }\r\n"
"      }\r\n"
"\r\n"
"      wmops[i].current_selfcnt = 0;\r\n"
"\r\n"
"      if (wmops[i].current_cnt > 0)\r\n"
"      {\r\n"
"          if (wmops[i].current_cnt > wmops[i].max_cnt)\r\n"
"          {\r\n"
"              wmops[i].max_cnt = wmops[i].current_cnt;\r\n"
"          }\r\n"
"\r\n"
"          if (wmops[i].current_cnt < wmops[i].min_cnt)\r\n"
"          {\r\n"
"              wmops[i].min_cnt = wmops[i].current_cnt;\r\n"
"          }\r\n"
"\r\n"
"          wmops[i].update_cnt++;\r\n"
"      }\r\n"
"\r\n"
"      wmops[i].current_cnt = 0;\r\n"
"  }\r\n"
"\r\n"
"  current_cnt = ops_cnt - start_cnt;\r\n"
"  if (current_cnt > max_cnt)\r\n"
"  {\r\n"
"      max_cnt = current_cnt;\r\n"
"\r\n"
"      for (i = 0; i < NUM_INST; i++)\r\n"
"      {\r\n"
"          inst_cnt_wc[i] = inst_cnt[i];\r\n"
"      }\r\n"
"\r\n"
"      fnum_cnt_wc = update_cnt + 1;\r\n"
"  }\r\n"
"\r\n"
"  if (current_cnt < min_cnt)\r\n"
"  {\r\n"
"      min_cnt = current_cnt;\r\n"
"  }\r\n"
"\r\n"
"  for (i = 0; i < NUM_INST; i++)\r\n"
"  {\r\n"
"      inst_cnt[i] = 0.0;\r\n"
"  }\r\n"
"\r\n"
"  start_cnt = ops_cnt;\r\n"
"  update_cnt++;\r\n"
"\r\n"
"  return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void print_wmops (void)\r\n"
"{\r\n"
"  int i;\r\n"
"\r\n"
"  char *sfmts = \"%20s %8s %8s %7s %7s\\n\";\r\n"
"  char *dfmts = \"%20s %8.2f %8.3f %7.3f %7.3f\\n\";\r\n"
"  char *sfmt =  \"%20s %8s %8s %7s %7s  %7s %7s %7s\\n\";\r\n"
"  char *dfmt =  \"%20s %8.2f %8.3f %7.3f %7.3f  %7.3f %7.3f %7.3f\\n\";\r\n"
"\r\n"
"#if ENABLE_TREE\r\n"
"\r\n"
"  int j;\r\n"
"  char *sfmtt =  \"%20s %4s %15s\\n\";\r\n"
"  char *dfmtt =  \"%20s %4d  \";\r\n"
"\r\n"
"#endif\r\n"
"\r\n"
"  fprintf(stdout, \"\\n\\n --- Weighted MOPS Analysis ---  \\n\\n\");\r\n"
"  fprintf(stdout, \"WMOPS boost factor: %4.2f\\n\\n\", WMOPS_BOOST_FAC);\r\n"
"\r\n"
"  fprintf(stdout, \"%54s  %23s\\n\", \"|------  SELF  ------|\"\r\n"
"                                  ,\"|---  CUMULATIVE  ---|\");\r\n"
"  fprintf(stdout, sfmt, \"        routine\", \" calls\", \"  min \", \"  max \", \"  avg \", \"  min \", \"  max \", \"  avg \");\r\n"
"  fprintf(stdout, sfmt, \"---------------\", \"------\", \"------\", \"------\", \"------\", \"------\", \"------\", \"------\");\r\n"
"  for (i = 0; i < num_records; i++)\r\n"
"  {\r\n"
"      fprintf(stdout, dfmt,\r\n"
"          wmops[i].label,\r\n"
"          (float)wmops[i].call_number / update_cnt,\r\n"
"          FAC * wmops[i].min_selfcnt,\r\n"
"          FAC * wmops[i].max_selfcnt,\r\n"
"          /* FAC*wmops[i].tot_selfcnt/update_cnt, */\r\n"
"          FAC * wmops[i].tot_selfcnt / wmops[i].update_cnt,             /* added -- JPA */\r\n"
"          FAC * wmops[i].min_cnt,\r\n"
"          FAC * wmops[i].max_cnt,\r\n"
"          /* FAC*wmops[i].tot_cnt/update_cnt); */\r\n"
"          FAC * wmops[i].tot_cnt / wmops[i].update_cnt);                /* added -- JPA */\r\n"
"  }\r\n"
"  fprintf (stdout, sfmts, \"---------------\", \"------\", \"------\", \"------\", \"------\");\r\n"
"  fprintf (stdout, dfmts, \r\n"
"           \"total\",\r\n"
"           (float)update_cnt,\r\n"
"           FAC*min_cnt,\r\n"
"           FAC*max_cnt,\r\n"
"           FAC*ops_cnt/update_cnt);\r\n"
"  fprintf (stdout, \"\\n\"); \r\n"
"\r\n"
"#if ENABLE_TREE\r\n"
"  fprintf (stdout, \"\\nCall Tree:\\n\\n\");\r\n"
"  fprintf (stdout, sfmtt, \"       function\", \"num\", \"called by:    \");\r\n"
"  fprintf (stdout, sfmtt, \"---------------\", \"---\", \"--------------\");\r\n"
"\r\n"
"  for (i = 0; i < num_records; i++)\r\n"
"    {\r\n"
"      fprintf (stdout, dfmtt, wmops[i].label, i);\r\n"
"      for (j = 0; wmops[i].call_tree[j] != -1; j++)\r\n"
"        {\r\n"
"          if (j != 0)\r\n"
"            {\r\n"
"              fprintf (stdout, \", \");\r\n"
"            }\r\n"
"          fprintf (stdout, \"%d\", wmops[i].call_tree[j]);\r\n"
"        }\r\n"
"      fprintf (stdout, \"\\n\");\r\n"
"\r\n"
"    }\r\n"
"\r\n"
"  fprintf (stdout, sfmtt, \"---------------\", \"---\", \"--------------\");\r\n"
"  fprintf (stdout, \"\\n\\n\");\r\n"
"\r\n"
"  fprintf(stdout, \"\\nInstruction Type Analysis (for worst case frame #%ld):\\n\\n\", fnum_cnt_wc);   /* added -- JPA */\r\n"
"  for (i = 0; i < NUM_INST; i++)\r\n"
"  {\r\n"
"      switch ((enum instructions)i)\r\n"
"      {\r\n"
"      case _ADD:       fprintf(stdout, \"\\tAdds:          %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _ABS:       fprintf(stdout, \"\\tAbsolutes:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _MULT:      fprintf(stdout, \"\\tMultiplies:    %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _MAC:       fprintf(stdout, \"\\tMACs:          %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _MOVE:      fprintf(stdout, \"\\tMoves:         %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _STORE:     fprintf(stdout, \"\\tStores:        %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _LOGIC:     fprintf(stdout, \"\\tLogicals:      %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _SHIFT:     fprintf(stdout, \"\\tShifts:        %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _BRANCH:    fprintf(stdout, \"\\tBranches:      %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _DIV:       fprintf(stdout, \"\\tDivisions:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _SQRT:      fprintf(stdout, \"\\tSquare Root:   %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _TRANS:     fprintf(stdout, \"\\tTrans:         %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _FUNC:      fprintf(stdout, \"\\tFunc Call:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _LOOP:      fprintf(stdout, \"\\tLoop Init:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _INDIRECT:  fprintf(stdout, \"\\tIndirect Addr: %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _PTR_INIT:  fprintf(stdout, \"\\tPointer Init:  %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _TEST:      fprintf(stdout, \"\\tExtra condit.: %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _POWER:     fprintf(stdout, \"\\tExponential:   %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _LOG:       fprintf(stdout, \"\\tLogarithm:     %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      case _MISC:      fprintf(stdout, \"\\tAll other op.: %12.1f\\n\", inst_cnt_wc[i]);  break;\r\n"
"      default:         fprintf(stdout, \"\\tERROR: Invalid instruction type: %d\\n\\n\", i);\r\n"
"      }\r\n"
"  }\r\n"
"#endif\r\n"
"\r\n"
"  return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * Stack counting tool\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"int16_t* ptr_base_stack = 0; /* Pointer to the bottom of stack (base pointer). Stack grows up. */\r\n"
"int16_t* ptr_max_stack = 0;  /* Pointer to the maximum stack pointer (the farest point from the bottom of stack) */\r\n"
"int32_t wc_frame = 0;        /* Frame corresponding to the worst-case stack usage */\r\n"
"char location_max_stack[256] = \"undefined\";\r\n"
"#define MAX_FCT_NAME_LENGTH 30\r\n"
"\r\n"
"typedef struct\r\n"
"{\r\n"
"    char function_name[MAX_FCT_NAME_LENGTH + 1];\r\n"
"    int16_t* stack_ptr;\r\n"
"} caller_info;\r\n"
"int current_calls = 0;\r\n"
"#define MAX_RECORDABLE_CALLS 40\r\n"
"caller_info stack_callers[2][MAX_RECORDABLE_CALLS];\r\n"
"\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * reset_stack()\r\n"
" *\r\n"
" * Initialize/reset the base stack counter..\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"void reset_stack()\r\n"
"{\r\n"
"    int16_t something;\r\n"
"\r\n"
"    ptr_base_stack = &something;\r\n"
"    ptr_max_stack = ptr_base_stack;\r\n"
"}\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * push_stack()\r\n"
" *\r\n"
" * Check the current stack pointer and update the maximum stack pointer, if new maximum found.\r\n"
" *--------------------------------------------------------------------*/\r\n"
"\r\n"
"int push_stack(const char* filename, const char* fctname)\r\n"
"{\r\n"
"    int16_t something;\r\n"
"\r\n"
"    (void)*filename; /* to avoid compilation warning */\r\n"
"\r\n"
"    /* Is there room to save the caller's information? */\r\n"
"    if (current_calls >= MAX_RECORDABLE_CALLS)\r\n"
"    { /* No */\r\n"
"        fprintf(stderr, \"No more room to store call stack info. Please increase MAX_RECORDABLE_CALLS\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Valid Function Name? */\r\n"
"    if (fctname[0] == 0)\r\n"
"    { /* No */\r\n"
"        fprintf(stderr, \"Invalid function name for call stack info.\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Save the Name of the Calling Function in the Table */\r\n"
"    strncpy(stack_callers[0][current_calls].function_name, fctname, MAX_FCT_NAME_LENGTH);\r\n"
"    stack_callers[0][current_calls].function_name[MAX_FCT_NAME_LENGTH] = 0; /* Nul Terminate */\r\n"
"\r\n"
"    /* Save the Stack Pointer */\r\n"
"    stack_callers[0][current_calls].stack_ptr = &something;\r\n"
"\r\n"
"    /* Increase Stack Calling Tree Level */\r\n"
"    current_calls++;\r\n"
"\r\n"
"    /* Is this the First Time or the Worst Case? */\r\n"
"    if (&something < ptr_max_stack || ptr_max_stack == NULL)\r\n"
"    { /* Yes */\r\n"
"        /* Save Info about it */\r\n"
"        ptr_max_stack = &something;\r\n"
"\r\n"
"        //wc_frame = frame;\r\n"
"        wc_frame = update_cnt;\r\n"
"        strncpy(location_max_stack, fctname, sizeof(location_max_stack) - 1);\r\n"
"        location_max_stack[sizeof(location_max_stack) - 1] = '\\0';\r\n"
"\r\n"
"        /* Save Call Tree */\r\n"
"        memmove(stack_callers[1], stack_callers[0], sizeof(caller_info) * current_calls);\r\n"
"\r\n"
"        /* Terminate the List (Unless Full) */\r\n"
"        if (current_calls < MAX_RECORDABLE_CALLS)\r\n"
"        {\r\n"
"            stack_callers[1][current_calls].function_name[0] = 0;\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    return 0 /* for Now */;\r\n"
"}\r\n"
"\r\n"
"int pop_stack(const char* filename, const char* fctname)\r\n"
"{\r\n"
"    caller_info* caller_info_ptr;\r\n"
"\r\n"
"    (void)*filename; /* to avoid compilation warning */\r\n"
"\r\n"
"    /* Decrease Stack Calling */\r\n"
"    current_calls--;\r\n"
"\r\n"
"    /* Get Pointer to Caller Information */\r\n"
"    caller_info_ptr = &stack_callers[0][current_calls];\r\n"
"\r\n"
"    /* Check if Names Match */\r\n"
"    if (strncmp(caller_info_ptr->function_name, fctname, MAX_FCT_NAME_LENGTH) != 0)\r\n"
"    {\r\n"
"        fprintf(stderr, \"Invalid usage of pop_stack()\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Erase Entry */\r\n"
"    caller_info_ptr->function_name[0] = 0;\r\n"
"\r\n"
"    return 0 /* for Now */;\r\n"
"}\r\n"
"\r\n"
"void print_stack_call_tree(void)\r\n"
"{\r\n"
"    caller_info* caller_info_ptr;\r\n"
"    int call_level;\r\n"
"\r\n"
"    fprintf(stdout, \"Stack Call Tree (frame #%d):\\n\", wc_frame);\r\n"
"    caller_info_ptr = &stack_callers[1][0];\r\n"
"    for (call_level = 0; call_level < MAX_RECORDABLE_CALLS; call_level++)\r\n"
"    {\r\n"
"        /* Done? */\r\n"
"        if (caller_info_ptr->function_name[0] == 0)\r\n"
"            break;\r\n"
"\r\n"
"        /* Print Name */\r\n"
"        fprintf(stdout, \"%-42s\", caller_info_ptr->function_name);\r\n"
"\r\n"
"        /* Print Stack Usage (Based on Difference) */\r\n"
"        if (call_level != 0)\r\n"
"        {\r\n"
"            fprintf(stdout, \"%ld\\n\", ((caller_info_ptr - 1)->stack_ptr - caller_info_ptr->stack_ptr) * sizeof(int16_t) / sizeof(float));\r\n"
"        }\r\n"
"        else\r\n"
"        {\r\n"
"            fprintf(stdout, \"\\n\");\r\n"
"        }\r\n"
"\r\n"
"        /* Advance */\r\n"
"        caller_info_ptr++;\r\n"
"    }\r\n"
"\r\n"
"    fprintf(stdout, \"\\n\");\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"\r\n"
"/*-------------------------------------------------------------------*\r\n"
" * RAM Counting Tool\r\n"
" *-------------------------------------------------------------------*/\r\n"
"\r\n"
"/* How to use the tool notes\r\n"
"   =========================\r\n"
"\r\n"
"   The tool measures dynamic memory allocated by malloc(), calloc() and deallocated by free().\r\n"
"\r\n"
"   In order to run the tool, one needs to:\r\n"
"     1) Call mem_count_init() at the beginning of the encoding/decoding process\r\n"
"        - The first param allows to set a limit on the RAM that can be allocated.\r\n"
"          While the codec is running, if memory is requested such that the maximum\r\n"
"          is passed (Mem Alloc > Limit), the codec will stop and the summary will\r\n"
"          be printed.\r\n"
"        - The second param allows to decide the units (bytes, shorts or longs).\r\n"
"          Please note that the unit specified is combined with the limit param to\r\n"
"          produce the total size that can be allocated. Ex ..init(1000, USE_16BITS);\r\n"
"          will set the limit to 1000 x 16 Bits Word (2000 bytes in total).\r\n"
"     2) Call mem_count_summary() at the end of the encoding/decoding process to print-out the results.\r\n"
"        - The first parameter allows to overwrite the initial units configuration.\r\n"
"          The Total size allocated (always in bytes internally) will be converted\r\n"
"          to the unit selected before being reported.\r\n"
"\r\n"
"   The macro 'WMOPS' needs to be activated to enable memory counting.\r\n"
"   To avoid the isntrumentation of any malloc()/calloc()/free() calls, wrap it with\r\n"
"   #define WMC_TOOL_MAN ... #undef WMC_TTOL_MAN macro pair.\r\n"
"   Optionally, it is possible to activate the macro 'MEM_COUNT_DETAILS' to print detailed sub-structure information.\r\n"
"*/\r\n"
"\r\n"
"/* Local Constants */\r\n"
"\r\n"
"/* This is the maximum number of allocations for which to keep information.\r\n"
"   It can be increased if required. */\r\n"
"#define MAX_INFO_RECORDS 3000\r\n"
"\r\n"
"/* This is the length after which the function name\r\n"
"   will be truncated when the summary is printed. */\r\n"
"#define MAX_FUNCTION_NAME_LENGTH 18\r\n"
"\r\n"
"/* This is the length after which the parameter to\r\n"
"   the allocating function will be truncated when\r\n"
"   the summary is printed. */\r\n"
"#define MAX_PARAMS_LENGTH 36\r\n"
"\r\n"
"/* This is the value (in bytes) towards which the block size\r\n"
"   is rounded. For example, a block of 123 bytes, when using\r\n"
"   a 32 bits system, will end up taking 124 bytes since\r\n"
"   the last unused byte cannot be used for another block. */\r\n"
"#ifdef MEM_ALIGN_64BITS\r\n"
"#define BLOCK_ROUNDING 8\r\n"
"#else /* Align on 32 Bits Instead */\r\n"
"#define BLOCK_ROUNDING 4\r\n"
"#endif\r\n"
"\r\n"
"#define N_32BITS_BLOCKS ( BLOCK_ROUNDING / sizeof( int32_t ) )\r\n"
"\r\n"
" /* Special Value to See if Memory was ever written */\r\n"
"#define MAGIC_VALUE_OOB  0x12A534F0           /* Put Before & After Buffer */\r\n"
"#define MAGIC_VALUE_USED ( ~MAGIC_VALUE_OOB ) /* To Detect if Memory was Written */\r\n"
"/* OOB Flags */\r\n"
"#define OOB_START 0x1\r\n"
"#define OOB_END   0x2\r\n"
"\r\n"
"/* Local Macros */\r\n"
"#define ROUND_BLOCK_SIZE( n ) ( ( ( n ) + BLOCK_ROUNDING - 1 ) & ~( BLOCK_ROUNDING - 1 ) )\r\n"
"#define IS_CALLOC( str )      ( ( size_str[0] ) == 'c' )\r\n"
"\r\n"
"/* Local Types */\r\n"
"typedef struct\r\n"
"{\r\n"
"    void* block_ptr;\r\n"
"    size_t block_size;\r\n"
"    int lineno;\r\n"
"    char name[MAX_FUNCTION_NAME_LENGTH + 1]; /* +1 for NUL */\r\n"
"    char params[1 + MAX_PARAMS_LENGTH + 1];  /* +1 for 'm'/'c' alloc & +1 for NUL */\r\n"
"    int used;\r\n"
"    int OOB_Flag;\r\n"
"    int seq_no; /* To Help Sorting by Order of Creation when all else is identical */\r\n"
"    int noccurances;\r\n"
"} allocator_record;\r\n"
"\r\n"
"typedef allocator_record allocation_list[MAX_INFO_RECORDS];\r\n"
"\r\n"
"/* Local Data */\r\n"
"static allocation_list Current_Allocations, Peak_Allocations, Freed_Allocations;\r\n"
"static size_t RAM_Limit = NO_RAM_LIMIT;      /* Always in Bytes */\r\n"
"static size_t Current_RAM = 0, Peak_RAM = 0; /* In Bytes */\r\n"
"static unsigned int Num_Records_Cur_RAM = 0, Num_Records_Peak_RAM = 0, Num_Records_Freed_RAM = 0;\r\n"
"static int Seq_No = 0;\r\n"
"\r\n"
"static size_t Stat_Cnt_Size = USE_BYTES;\r\n"
"\r\n"
"#ifndef DISABLE_NULL_PTR_FREE_WARNING\r\n"
"static allocation_list Missing_Allocations;\r\n"
"static unsigned int Num_Records_Missing_Alloc_Warnings = 0;\r\n"
"#endif\r\n"
"\r\n"
"/* Suffix after numeral value printed in the summary */\r\n"
"/* One char for each size */\r\n"
"static const char Count_suffix[] = \"BsL\"; /* Using 's' because 'S' looks like '5'. */\r\n"
"static const char* Count_Name[] = { \"Bytes\", \"Shorts\", \"Longs\" };\r\n"
"\r\n"
"/* Global Functions */\r\n"
"\r\n"
"/* It is not necessary to call dyn_mem_stats_init() since all static\r\n"
"   variables are pre-initialised. It can be used to run stats again. */\r\n"
"void mem_count_init(size_t limit, Counting_Size cnt_size)\r\n"
"{\r\n"
"    if (cnt_size != USE_DEFAULT)\r\n"
"        Stat_Cnt_Size = cnt_size;\r\n"
"    Current_RAM = Peak_RAM = 0;\r\n"
"    RAM_Limit = limit << Stat_Cnt_Size;\r\n"
"    Num_Records_Cur_RAM = Num_Records_Peak_RAM = Num_Records_Freed_RAM = 0;\r\n"
"#ifndef DISABLE_NULL_PTR_FREE_WARNING\r\n"
"    Num_Records_Missing_Alloc_Warnings = 0;\r\n"
"#endif\r\n"
"    Seq_No = 0;\r\n"
"}\r\n"
"\r\n"
"/* This Function basically uses 'malloc' to allocate memory but also\r\n"
"   records information about which functions allocated memory, the peak, ...\r\n"
"   When, dyn_mem_print_stats() is called, all this info is printed as\r\n"
"   well as the memory that has not been de-allocated; it is useful to\r\n"
"   find memory leaks. */\r\n"
"void* mem_alloc(\r\n"
"    const char* func_name,\r\n"
"    int func_lineno,\r\n"
"    size_t size,\r\n"
"    char* size_str /* the first char indicates m-alloc or c-alloc */)\r\n"
"{\r\n"
"    size_t rounded_size;\r\n"
"    void* block_ptr;\r\n"
"    char* tmp_ptr;\r\n"
"    allocator_record* record_ptr;\r\n"
"    size_t n, f;\r\n"
"    int32_t fill_value;\r\n"
"    int32_t* ptr32;\r\n"
"    int32_t mask, temp;\r\n"
"    unsigned int check;\r\n"
"\r\n"
"    /* Do not Support Empty Requests */\r\n"
"    if (size == 0)\r\n"
"    {\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Size of Zero not Supported\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    if (Num_Records_Cur_RAM == MAX_INFO_RECORDS)\r\n"
"    {\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Too Many Allocs. Increase 'MAX_INFO_RECORDS'\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Round Up Block Size */\r\n"
"    rounded_size = ROUND_BLOCK_SIZE(size);\r\n"
"\r\n"
"    /* Allocate using the standard mem allocator.\r\n"
"       Allocate a bit More to Have Room for Signature Values */\r\n"
"    block_ptr = malloc(rounded_size + BLOCK_ROUNDING * 2);\r\n"
"\r\n"
"    /* the split line is to prevent a 'search/replace' adding a '_' to the name */\r\n"
"    /* We request more memory to have room to put signatures at the start\r\n"
"       and end of the allocated buffer to check for OOBounds accesses. */\r\n"
"       /* Stop if it Failed */\r\n"
"    if (block_ptr == NULL)\r\n"
"    {\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Out of System RAM\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Cannot use #if sizeof(int32_t) to catch this at compile time\r\n"
"       because the preprocessor doesn't know anything about types\r\n"
"       or sizes. */\r\n"
"    check = sizeof(int32_t);\r\n"
"    if (check != 4)\r\n"
"    {\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Expecting 'int32_t' to be a 32 Bits Integer\");\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"\r\n"
"    /* Set Signatures and Fill (or Clear) Memory */\r\n"
"    ptr32 = (int32_t*)block_ptr;\r\n"
"    /* Signature at Start of Block */\r\n"
"    n = N_32BITS_BLOCKS;\r\n"
"    do\r\n"
"    {\r\n"
"        *ptr32++ = MAGIC_VALUE_OOB;\r\n"
"    } while (--n);\r\n"
"    /* Fill with Pattern or Clear Memory */\r\n"
"    fill_value = MAGIC_VALUE_USED;\r\n"
"    if (IS_CALLOC(size_str))\r\n"
"    {\r\n"
"        fill_value = 0x00000000;\r\n"
"    }\r\n"
"    n = size / sizeof(int32_t);\r\n"
"    while (n--)\r\n"
"    {\r\n"
"        *ptr32++ = fill_value;\r\n"
"    }\r\n"
"    n = rounded_size - size;\r\n"
"    /* When Initializing with '0' */\r\n"
"    /* Need to Adapt the Magic Value */\r\n"
"    f = n % sizeof(int32_t);\r\n"
"    if (f != 0)\r\n"
"    {\r\n"
"        /* For f=, shift by [1->24, 2->16, 3->8] */\r\n"
"        mask = 0xFFFFFFFF << ((sizeof(int32_t) - f) * 8); /* (1) */\r\n"
"        temp = MAGIC_VALUE_OOB & mask;\r\n"
"        if (fill_value != 0x0)\r\n"
"        { /* Using M-Alloc */\r\n"
"            /* Merge Fill Value */\r\n"
"            temp += (~mask) & MAGIC_VALUE_USED;\r\n"
"        } /* for C-Alloc, the code in (1) hereabove already introduces zeros */\r\n"
"        *ptr32++ = temp;\r\n"
"    }\r\n"
"    n /= sizeof(int32_t);\r\n"
"    n += N_32BITS_BLOCKS;\r\n"
"    /* Signature at End of Block */\r\n"
"    do\r\n"
"    {\r\n"
"        *ptr32++ = MAGIC_VALUE_OOB;\r\n"
"    } while (--n);\r\n"
"\r\n"
"    /* Adjust Pointer (Magic Value Before and After the Memory Region Requested) */\r\n"
"    tmp_ptr = (char*)block_ptr;\r\n"
"    tmp_ptr += BLOCK_ROUNDING;\r\n"
"    block_ptr = (void*)tmp_ptr;\r\n"
"\r\n"
"    /* Save Information about Function Requesting the RAM */\r\n"
"    record_ptr = &Current_Allocations[Num_Records_Cur_RAM];\r\n"
"\r\n"
"    /* Save Name (and NUL Terminate it) */\r\n"
"    strncpy(record_ptr->name, func_name, MAX_FUNCTION_NAME_LENGTH);\r\n"
"    record_ptr->name[MAX_FUNCTION_NAME_LENGTH] = '\\0';\r\n"
"    /* Save Params (and NUL Terminate it)\r\n"
"       There string starts with a Marker (either 'm' or 'c')\r\n"
"       that indicates the type of allocation requested. */\r\n"
"    strncpy(record_ptr->params, size_str, MAX_PARAMS_LENGTH);\r\n"
"    record_ptr->params[MAX_PARAMS_LENGTH] = '\\0';\r\n"
"    /* Save Other Info */\r\n"
"    record_ptr->lineno = func_lineno;\r\n"
"    record_ptr->block_ptr = block_ptr;\r\n"
"    record_ptr->block_size = size;\r\n"
"    record_ptr->used = -1; /* By default do not check mem usage */\r\n"
"    record_ptr->seq_no = ++Seq_No;\r\n"
"    record_ptr->noccurances = 1;\r\n"
"\r\n"
"    /* Increase # of Records */\r\n"
"    Num_Records_Cur_RAM++;\r\n"
"    /* Update Amount of RAM Allocated */\r\n"
"    Current_RAM += rounded_size;\r\n"
"\r\n"
"    /* Is this the Worst Case */\r\n"
"    if (Peak_RAM < Current_RAM)\r\n"
"    { /* Yes */\r\n"
"        /* Update the Peak RAM */\r\n"
"        Peak_RAM = Current_RAM;\r\n"
"        /* Keep the Information */\r\n"
"        memmove(Peak_Allocations, Current_Allocations, sizeof(allocator_record) * Num_Records_Cur_RAM);\r\n"
"        Num_Records_Peak_RAM = Num_Records_Cur_RAM;\r\n"
"    }\r\n"
"\r\n"
"    /* Limit Busted? */\r\n"
"    if (RAM_Limit != NO_RAM_LIMIT)\r\n"
"    {\r\n"
"        if (Current_RAM > RAM_Limit)\r\n"
"        {\r\n"
"            char info_msg[100];\r\n"
"            sprintf(info_msg, \"Alloc Limit of %lu %s was Passed\", (unsigned long)RAM_Limit >> Stat_Cnt_Size, Count_Name[Stat_Cnt_Size]);\r\n"
"            printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, info_msg);\r\n"
"\r\n"
"#ifdef MEM_COUNT_DETAILS\r\n"
"            mem_count_summary(USE_DEFAULT);\r\n"
"#endif\r\n"
"            exit(-1);\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    return block_ptr;\r\n"
"}\r\n"
"\r\n"
"/* Calculate Memory Usage of Block (Look for Signature) */\r\n"
"static void mem_set_usage(allocator_record* record_ptr)\r\n"
"{\r\n"
"    int total_bytes_used;\r\n"
"\r\n"
"    size_t n;\r\n"
"    int32_t* ptr32;\r\n"
"    char* ptr8;\r\n"
"    size_t total_bytes;\r\n"
"    int32_t fill_value;\r\n"
"\r\n"
"    fill_value = MAGIC_VALUE_USED;\r\n"
"    if ((record_ptr->params[0]) == 'c')\r\n"
"    {\r\n"
"        fill_value = 0x00000000;\r\n"
"    }\r\n"
"\r\n"
"    total_bytes = record_ptr->block_size;\r\n"
"\r\n"
"    /* Check 4 bytes at a time */\r\n"
"    ptr32 = (int32_t*)record_ptr->block_ptr;\r\n"
"    total_bytes_used = 0;\r\n"
"    for (n = total_bytes / sizeof(int32_t); n > 0; n--)\r\n"
"    {\r\n"
"        if (*ptr32++ != fill_value)\r\n"
"            total_bytes_used += sizeof(int32_t);\r\n"
"    }\r\n"
"\r\n"
"    /* Check Remaining Bytes (If Applicable) */\r\n"
"    ptr8 = (char*)ptr32;\r\n"
"    for (n = total_bytes % sizeof(int32_t); n > 0; n--)\r\n"
"    {\r\n"
"        if (*ptr8++ != (char)fill_value)\r\n"
"            total_bytes_used++;\r\n"
"        /* Update Value */\r\n"
"        fill_value >>= 8;\r\n"
"    }\r\n"
"\r\n"
"    /* Save Space Used */\r\n"
"    record_ptr->used = total_bytes_used;\r\n"
"}\r\n"
"\r\n"
"static void mem_check_OOB(allocator_record* record_ptr)\r\n"
"{\r\n"
"    int32_t* ptr32;\r\n"
"    unsigned int OOB_Flag = 0x0;\r\n"
"    int32_t mask;\r\n"
"    size_t i;\r\n"
"    int f;\r\n"
"\r\n"
"    ptr32 = (int32_t*)record_ptr->block_ptr - N_32BITS_BLOCKS;\r\n"
"    /* Check at Beginning of Block */\r\n"
"    i = N_32BITS_BLOCKS;\r\n"
"    do\r\n"
"    {\r\n"
"        if (*ptr32++ ^ MAGIC_VALUE_OOB)\r\n"
"            OOB_Flag |= OOB_START;\r\n"
"    } while (--i);\r\n"
"\r\n"
"    /* Advance to End (Snap to lowest 32 Bits) */\r\n"
"    ptr32 += record_ptr->block_size / sizeof(int32_t);\r\n"
"\r\n"
"    /* Calculate Unused Space That has been\r\n"
"       added to get to the rounded Block Size */\r\n"
"    i = ROUND_BLOCK_SIZE(record_ptr->block_size) - record_ptr->block_size;\r\n"
"\r\n"
"    /* Partial Check (For Block Size that have been rounded) */\r\n"
"    f = i % sizeof(int32_t);\r\n"
"    if (f != 0)\r\n"
"    {\r\n"
"        mask = 0xFFFFFFFF << ((sizeof(int32_t) - f) * 8);\r\n"
"        if ((*ptr32++ ^ MAGIC_VALUE_OOB) & mask)\r\n"
"            OOB_Flag |= OOB_END;\r\n"
"    }\r\n"
"\r\n"
"    /* Full Check (all 32 Bits) for Remaining */\r\n"
"    i /= sizeof(int32_t);\r\n"
"    i += N_32BITS_BLOCKS;\r\n"
"    do\r\n"
"    {\r\n"
"        if (*ptr32++ ^ MAGIC_VALUE_OOB)\r\n"
"            OOB_Flag |= OOB_END;\r\n"
"    } while (--i);\r\n"
"\r\n"
"    record_ptr->OOB_Flag = OOB_Flag;\r\n"
"}\r\n"
"\r\n"
"/* Just to make the code cleaner */\r\n"
"static int is_same_record(const allocator_record* record_ptr1, allocator_record* record_ptr2)\r\n"
"{\r\n"
"    return record_ptr2->block_size == record_ptr1->block_size &&\r\n"
"        record_ptr2->lineno == record_ptr1->lineno &&\r\n"
"        strcmp(record_ptr2->name, record_ptr1->name) == 0 &&\r\n"
"        strcmp(record_ptr2->params, record_ptr1->params) == 0 &&\r\n"
"        record_ptr2->OOB_Flag == record_ptr1->OOB_Flag ? 1 : 0;\r\n"
"}\r\n"
"\r\n"
"/* This Function basically uses 'free' and removes the\r\n"
"   Information about the memory block from the list of\r\n"
"   currently allocated Memory */\r\n"
"void mem_free(const char* func_name, int func_lineno, void* ptr)\r\n"
"{\r\n"
"    unsigned int i, j, k;\r\n"
"    char* tmp_ptr;\r\n"
"    allocator_record* record_ptr, * record_ptr2;\r\n"
"\r\n"
"    char info_msg[100];\r\n"
"\r\n"
"    /* Search for the Block Pointer in the List */\r\n"
"    record_ptr = &Current_Allocations[0];\r\n"
"    for (i = 0; i < Num_Records_Cur_RAM; i++)\r\n"
"    {\r\n"
"        /* Same Pointer? */\r\n"
"        if (ptr == record_ptr->block_ptr)\r\n"
"        { /* Yes, Found it */\r\n"
"            if (Num_Records_Freed_RAM == MAX_INFO_RECORDS)\r\n"
"            {\r\n"
"                printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Too Many Allocs. Increase 'MAX_INFO_RECORDS'\");\r\n"
"                exit(-1);\r\n"
"            }\r\n"
"\r\n"
"            for (j = 0; j < Num_Records_Peak_RAM; j++)\r\n"
"            {\r\n"
"                /* Is this Block Part of the Peak RAM? */\r\n"
"                if (memcmp(record_ptr, &Peak_Allocations[j], sizeof(*record_ptr)) == 0)\r\n"
"                {\r\n"
"                    break; /* Stop the 'j' loop */\r\n"
"                }\r\n"
"            }\r\n"
"\r\n"
"            mem_set_usage(record_ptr);\r\n"
"            mem_check_OOB(record_ptr);\r\n"
"\r\n"
"            /* De-Allocated Block was Part of Peak RAM? */\r\n"
"            if (j == Num_Records_Peak_RAM)\r\n"
"            { /* No */\r\n"
"                /* Here, in order to avoid filling this list with repetitive blocks */\r\n"
"                /* that are allocated and deallocated repeatedly, we look for a block */\r\n"
"                /* that has the same module, line #, size & same OOB characteristics. */\r\n"
"                /* We then just increase the # of occurances of this block definition. */\r\n"
"                /* The % used will be merged */\r\n"
"                record_ptr2 = &Freed_Allocations[0];\r\n"
"                for (k = 0; k < Num_Records_Freed_RAM; k++)\r\n"
"                {\r\n"
"                    /* Same Block but allocated many times */\r\n"
"                    if (is_same_record(record_ptr2, record_ptr))\r\n"
"                    {\r\n"
"                        record_ptr2->noccurances++;\r\n"
"                        record_ptr2->used += record_ptr->used;\r\n"
"                        break;\r\n"
"                    }\r\n"
"                    record_ptr2++;\r\n"
"                }\r\n"
"                /* Found it */\r\n"
"            }\r\n"
"            else\r\n"
"            {\r\n"
"                /* Force Add to List */\r\n"
"                k = Num_Records_Freed_RAM;\r\n"
"            }\r\n"
"\r\n"
"            if (k == Num_Records_Freed_RAM)\r\n"
"            { /* No */\r\n"
"                /* Add to List */\r\n"
"                memmove(&Freed_Allocations[Num_Records_Freed_RAM], record_ptr, sizeof(allocator_record));\r\n"
"                /* Increase # of Records for Deallocated Block List */\r\n"
"                Num_Records_Freed_RAM++;\r\n"
"            }\r\n"
"\r\n"
"            /* De-Allocated Block was Part of Peak RAM? */\r\n"
"            if (j != Num_Records_Peak_RAM)\r\n"
"            { /* Yes */\r\n"
"                /* Update Block Info There too (The Info here is Bytes Used and OOB Flags) */\r\n"
"                memmove(&Peak_Allocations[j], record_ptr, sizeof(*record_ptr));\r\n"
"            }\r\n"
"\r\n"
"            /* First Adjust Pointer to Get to the Start of the Block */\r\n"
"            tmp_ptr = (char*)ptr;\r\n"
"            tmp_ptr -= BLOCK_ROUNDING;\r\n"
"            ptr = (void*)tmp_ptr;\r\n"
"            /* De-allocate using the standard memory facilities */\r\n"
"            free(ptr); /* the split line is to prevent a 'search/replace' adding a '_' to the name */\r\n"
"\r\n"
"                            /* Decrease # of Records */\r\n"
"            Num_Records_Cur_RAM--;\r\n"
"            /* Update (decrease) Amount of RAM Allocated */\r\n"
"            Current_RAM -= ROUND_BLOCK_SIZE(record_ptr->block_size);\r\n"
"\r\n"
"            /* Erase the entry (Move the Last One over it) */\r\n"
"            memmove(record_ptr, &Current_Allocations[Num_Records_Cur_RAM], sizeof(allocator_record));\r\n"
"\r\n"
"            return;\r\n"
"        }\r\n"
"        record_ptr++;\r\n"
"    }\r\n"
"\r\n"
"    /* Not Found, Problem! */\r\n"
"    if (ptr != NULL)\r\n"
"    {\r\n"
"        /* Stop */\r\n"
"        sprintf(info_msg, \"Invalid Pointer: '%p'\", ptr);\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, info_msg);\r\n"
"        exit(-1);\r\n"
"    }\r\n"
"#ifndef DISABLE_NULL_PTR_FREE_WARNING\r\n"
"    else\r\n"
"    { /* Warn about Freeing of NULL Pointers */\r\n"
"        /* Search to Warn Only Once. */\r\n"
"        record_ptr = &Missing_Allocations[0];\r\n"
"        for (i = 0; i < Num_Records_Missing_Alloc_Warnings; i++)\r\n"
"        {\r\n"
"            /* Same Name? */\r\n"
"            if (strncmp(record_ptr->name, func_name, MAX_FUNCTION_NAME_LENGTH) == 0)\r\n"
"            { /* Yes */\r\n"
"                /* Same Line Number? */\r\n"
"                if (record_ptr->lineno == func_lineno)\r\n"
"                { /* Yes */\r\n"
"                    /* No Need to Warn Again */\r\n"
"                    return;\r\n"
"                }\r\n"
"            }\r\n"
"            record_ptr++;\r\n"
"        }\r\n"
"        /* Save Name */\r\n"
"        strncpy(record_ptr->name, func_name, MAX_FUNCTION_NAME_LENGTH);\r\n"
"        record_ptr->name[MAX_FUNCTION_NAME_LENGTH] = '\\0';\r\n"
"\r\n"
"        /* Save Line No */\r\n"
"        record_ptr->lineno = func_lineno;\r\n"
"        /* Save Pointer */\r\n"
"        record_ptr->block_ptr = ptr;\r\n"
"        /* Save Size */\r\n"
"        record_ptr->block_size = 0; /* It is an Unknown Block, so there is no size, we put a '0' */\r\n"
"\r\n"
"        Num_Records_Missing_Alloc_Warnings++;\r\n"
"\r\n"
"        printf(\"Fct=%s, Ln=%i: %s!\\n\", func_name, func_lineno, \"Warning: Trying to Free 'NULL' Pointer\");\r\n"
"    }\r\n"
"#endif\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"#ifdef MEM_COUNT_DETAILS\r\n"
"/* Used to Sort Block Information Records */\r\n"
"static int compare_mem_records(const void* ptr1, const void* ptr2)\r\n"
"{\r\n"
"    const allocator_record* record_ptr1 = (const allocator_record*)ptr1,\r\n"
"        * record_ptr2 = (const allocator_record*)ptr2;\r\n"
"    int result;\r\n"
"\r\n"
"    /* Sort First by 'Name', then by 'Line No' and finaly by 'Block Size' */\r\n"
"\r\n"
"    /* Compare Function Name */\r\n"
"    result = strcmp(record_ptr1->name, record_ptr2->name);\r\n"
"    /* Same Function Name? */\r\n"
"    if (result == 0)\r\n"
"    { /* Yes */\r\n"
"        /* Compare Line Number */\r\n"
"        result = record_ptr1->lineno - record_ptr2->lineno;\r\n"
"        /* Same Line Number */\r\n"
"        if (result == 0)\r\n"
"        { /* Yes */\r\n"
"            /* Compare Block Size */\r\n"
"            result = record_ptr1->block_size - record_ptr2->block_size;\r\n"
"            /* Same Size? */\r\n"
"            if (result == 0)\r\n"
"            {\r\n"
"                result = record_ptr1->seq_no - record_ptr2->seq_no;\r\n"
"            }\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    return result;\r\n"
"}\r\n"
"\r\n"
"static void mem_print_records(allocator_record* record_ptr, int n_records, Counting_Size cnt_size, int print_size)\r\n"
"{\r\n"
"    int i, sum, total;\r\n"
"    char* last_name = NULL;\r\n"
"    int single_flag;\r\n"
"    char chr = Count_suffix[cnt_size];\r\n"
"    size_t nwords, rounded_block_size;\r\n"
"    char nblocks_str[22];\r\n"
"    char quantity_str[22];\r\n"
"    char format_str[50];\r\n"
"    char* tmp_ptr;\r\n"
"    int nblocks;\r\n"
"\r\n"
"    char* OOB_str[] = { \"- \", \"beg\", \"end\", \"b+e\" };\r\n"
"\r\n"
"    strcpy(format_str, \"\\n    %-*s %5i %-*s %3s %3.0f%% %8s\");\r\n"
"    if (print_size != 0)\r\n"
"        strcat(format_str, \" %6u\");\r\n"
"\r\n"
"    /* Sort it */\r\n"
"    qsort(record_ptr, n_records, sizeof(allocator_record), compare_mem_records);\r\n"
"\r\n"
"    single_flag = 0;\r\n"
"\r\n"
"    nblocks = 0;\r\n"
"\r\n"
"    if (n_records > 0)\r\n"
"    {\r\n"
"        /* Print Header */\r\n"
"        printf(\"    %-*s Ln No %-*s OOB Used Quantity%s\", MAX_FUNCTION_NAME_LENGTH, \"Function Name\", MAX_PARAMS_LENGTH, \"Parameters ('m' or 'c' alloc)\", print_size != 0 ? \"   Size\" : \"\");\r\n"
"\r\n"
"        total = sum = 0;\r\n"
"        for (i = n_records - 1; i >= 0; i--)\r\n"
"        {\r\n"
"            if (sum == 0)\r\n"
"            {\r\n"
"                last_name = record_ptr->name;\r\n"
"            }\r\n"
"\r\n"
"            rounded_block_size = ROUND_BLOCK_SIZE(record_ptr->block_size) >> cnt_size;\r\n"
"            nwords = rounded_block_size * record_ptr->noccurances;\r\n"
"\r\n"
"            /* Calc Usage (It has already been done for a De-Allocated Block\r\n"
"               That was part of the Peak Mem. But not for a Block that is\r\n"
"               still allocated (never freed). */\r\n"
"            if (record_ptr->used < 0)\r\n"
"            {\r\n"
"                mem_set_usage(record_ptr);\r\n"
"                /* Check Out of Bounds Too */\r\n"
"                mem_check_OOB(record_ptr);\r\n"
"            }\r\n"
"\r\n"
"            sprintf(quantity_str, \"%i\", record_ptr->noccurances);\r\n"
"\r\n"
"            /* Print Quantity x Size */\r\n"
"            tmp_ptr = strchr(quantity_str, '\\0');\r\n"
"            *tmp_ptr++ = 'x';\r\n"
"            sprintf(tmp_ptr, \"%i\", (int)rounded_block_size);\r\n"
"\r\n"
"            printf(format_str, MAX_FUNCTION_NAME_LENGTH, record_ptr->name, record_ptr->lineno, MAX_PARAMS_LENGTH, record_ptr->params, OOB_str[record_ptr->OOB_Flag], (record_ptr->used * 100.0f / record_ptr->block_size / record_ptr->noccurances), quantity_str, (uint32_t)nwords);\r\n"
"            /* Count $ of Blocks */\r\n"
"            nblocks += record_ptr->noccurances;\r\n"
"            /* Add Size */\r\n"
"            sum += nwords;\r\n"
"            /* Advance */\r\n"
"            record_ptr++;\r\n"
"\r\n"
"            if (print_size != 0)\r\n"
"            {\r\n"
"                /* End Reached or New Function? */\r\n"
"                if (i == 0 || strcmp(last_name, record_ptr->name) != 0)\r\n"
"                {\r\n"
"                    /* Cumulate Total */\r\n"
"                    total += sum;\r\n"
"\r\n"
"                    if (i == 0 && total == sum)\r\n"
"                        single_flag = 1;\r\n"
"#ifdef MEM_COUNT_TOTAL_PER_FUNC\r\n"
"                    /* Print 'Total' on the Line if there is only one Function\r\n"
"                       that allocated all the RAM */\r\n"
"                    printf(\" %7i%c\", sum, chr);\r\n"
"#endif\r\n"
"                    /* Reset Sum */\r\n"
"                    sum = 0;\r\n"
"                }\r\n"
"            }\r\n"
"        }\r\n"
"        /* Print the Total */\r\n"
"        if (!single_flag && print_size != 0)\r\n"
"        {\r\n"
"#ifdef MEM_COUNT_TOTAL_PER_FUNC\r\n"
"#define SPACES 9\r\n"
"#else\r\n"
"#define SPACES 0\r\n"
"#endif\r\n"
"\r\n"
"            sprintf(nblocks_str, \"%i Blocks\", nblocks);\r\n"
"\r\n"
"            printf(\"\\n    %*s %*s                      %*s  --------\\n\", MAX_FUNCTION_NAME_LENGTH, \"\", MAX_PARAMS_LENGTH, \"\", SPACES, \"\");\r\n"
"            printf(\"    %-*s       %-*s                  %*s%7i%c\\n\", MAX_FUNCTION_NAME_LENGTH, \"Total\", MAX_PARAMS_LENGTH, nblocks_str, SPACES, \"\", total, chr);\r\n"
"        }\r\n"
"        else\r\n"
"            printf(\"\\n\");\r\n"
"    }\r\n"
"    else\r\n"
"    {\r\n"
"        printf(\"    <None>\\n\");\r\n"
"    }\r\n"
"}\r\n"
"#endif\r\n"
"\r\n"
"#ifdef MEM_COUNT_DETAILS\r\n"
"/* Detailed SRAM Summary */\r\n"
"size_t mem_count_summary(Counting_Size cnt_size)\r\n"
"{\r\n"
"    printf(\"\\n\\n====== STATIC RAM COUNTING TOOL: MEMORY SUMMARY ======\\n\\n\");\r\n"
"\r\n"
"    printf(\"  NOTES\\n\"\r\n"
"        \"  1) %c = %s, %c = %s (16 Bits Words) & %c = %s (32 Bits Words).\\n\"\r\n"
"        \"  2) The '%%' of 'Used' memory is not very reliable for c-alloc.\\n\"\r\n"
"        \"  3) The Out Of Bounds (OOB) Checking is primitive as it checks\\n\"\r\n"
"        \"     only for writing before and past the buffer when it is freed\\n\"\r\n"
"        \"     or when the summary is printed.\\n\"\r\n"
"        \"  4) Quantity Filed format is N x Block Size.\\n\"\r\n"
"        \"     When it is 1: Size = Block Size\\n\"\r\n"
"        \"     Otherwise, Size = The Total Size Allocated for the 'N' Blocks.\\n\"\r\n"
"        \"\\n\",\r\n"
"        Count_suffix[USE_BYTES], Count_Name[USE_BYTES], Count_suffix[USE_16BITS], Count_Name[USE_16BITS], Count_suffix[USE_32BITS], Count_Name[USE_32BITS]);\r\n"
"\r\n"
"    /* Create a Temporary List of Block to Print */\r\n"
"    /* from all the Block Allocated in the Peak */\r\n"
"    /* Scenario. We want to Merge Entries allocated */\r\n"
"    /* from the exact same code location and having */\r\n"
"    /* the same block size. In order to simplifiy the */\r\n"
"    /* printout. */\r\n"
"    num = 0;\r\n"
"    for (i = 0; i < Num_Records_Peak_RAM; i++)\r\n"
"    {\r\n"
"        /* Check if an Identical Block Before Adding to List */\r\n"
"        for (j = 0; j < num; j++)\r\n"
"        {\r\n"
"            if (is_same_record(&Peak_Allocations[i], &Allocations[j]))\r\n"
"            {\r\n"
"                Allocations[j].noccurances++;\r\n"
"                Allocations[j].used += Peak_Allocations[i].used;\r\n"
"                break;\r\n"
"            }\r\n"
"        }\r\n"
"\r\n"
"        /* Unique Block? */\r\n"
"        if (j == num)\r\n"
"        { /* Yes */\r\n"
"            /* Add to List */\r\n"
"            memmove(&Allocations[num++], &Peak_Allocations[i], sizeof(allocator_record));\r\n"
"        }\r\n"
"    }\r\n"
"    /* Print the Peak Allocated */\r\n"
"    printf(\"  Peak Memory Allocated\\n\");\r\n"
"    mem_print_records(&Allocations[0], num, cnt_size, 1);\r\n"
"    printf(\"\\n\");\r\n"
"\r\n"
"    /* Create a Temporary List of Block to Print */\r\n"
"    /* from all the Block Allocated BUT excluding */\r\n"
"    /* blocks that are part of the peak (and that */\r\n"
"    /* are already printed). */\r\n"
"    /* This is done every time the summary is printed */\r\n"
"    /* so that the code can continue to be executed */\r\n"
"    /* and the summary can be printed again with blocks */\r\n"
"    /* that are part of the peak having changed and thus */\r\n"
"    /* those that end up in this 'catch all' category. */\r\n"
"    num = 0;\r\n"
"    for (i = 0; i < Num_Records_Freed_RAM; i++)\r\n"
"    {\r\n"
"        /* Check if Record is in the Peak */\r\n"
"        for (j = 0; j < Num_Records_Peak_RAM; j++)\r\n"
"        {\r\n"
"            /* Is this Block Part of the Peak RAM OR Still Allocated ? */\r\n"
"            if (is_same_record(&Freed_Allocations[i], &Peak_Allocations[j]))\r\n"
"            {          /* Yes */\r\n"
"                break; /* Stop the 'j' loop */\r\n"
"            }\r\n"
"        }\r\n"
"        /* If part of the Peak, skip it */\r\n"
"        if (j == Num_Records_Peak_RAM)\r\n"
"        { /* Not Part of Peak */\r\n"
"            /* Check if an Identical Block Before Adding to List */\r\n"
"            for (j = 0; j < num; j++)\r\n"
"            {\r\n"
"#ifndef MEM_COUNT_SEPARATE_OTHER_BLOCKS\r\n"
"                /* Just Check for Same Size, Params and OOB Result */\r\n"
"                if (Freed_Allocations[i].block_size == Allocations[j].block_size &&\r\n"
"                    strcmp(Freed_Allocations[i].params, Allocations[j].params) == 0 &&\r\n"
"                    Freed_Allocations[i].OOB_Flag == Allocations[j].OOB_Flag)\r\n"
"                {\r\n"
"                    Allocations[j].noccurances += Freed_Allocations[i].noccurances;\r\n"
"                    Allocations[j].used += Freed_Allocations[i].used;\r\n"
"                    /* Indicate that Locations are Multiple */\r\n"
"                    strncpy(Allocations[j].name, \"MULTIPLE LOCATIONS\", MAX_FUNCTION_NAME_LENGTH);\r\n"
"                    /* Wipe the Line # */\r\n"
"                    Allocations[j].lineno = 0;\r\n"
"                    break;\r\n"
"                }\r\n"
"#else\r\n"
"                if (is_same_record(&Freed_Allocations[i], &Allocations[j]))\r\n"
"                {\r\n"
"                    Allocations[j].noccurances++;\r\n"
"                    Allocations[j].used += Freed_Allocations[i].used;\r\n"
"                    break;\r\n"
"                }\r\n"
"#endif\r\n"
"            }\r\n"
"\r\n"
"            /* Unique Block? */\r\n"
"            if (j == num)\r\n"
"            { /* Yes */\r\n"
"                /* Add to List */\r\n"
"                memmove(&Allocations[num++], &Freed_Allocations[i], sizeof(allocator_record));\r\n"
"            }\r\n"
"        }\r\n"
"    }\r\n"
"\r\n"
"    if (num != 0)\r\n"
"    {\r\n"
"        /* Print all Other Block (Those that have been Freed but are not Part\r\n"
"           of the Peak Memory). */\r\n"
"        printf(\"  Other Memory Allocated\\n\");\r\n"
"        mem_print_records(&Allocations[0], num, cnt_size, 0 /*Do not print the size column*/);\r\n"
"        printf(\"\\n\");\r\n"
"    }\r\n"
"\r\n"
"    /* If we have busted the RAM Limit, we will end up in the\r\n"
"       summary function (here) and abort. Hence, no point printing\r\n"
"       the memory still allocated, it will be the same as the Peak! */\r\n"
"    if (RAM_Limit == 0 || Current_RAM <= RAM_Limit)\r\n"
"    {\r\n"
"        /* Print the Not Deallocated */\r\n"
"        printf(\"  Memory Still Allocated\\n\");\r\n"
"        mem_print_records(&Current_Allocations[0], Num_Records_Cur_RAM, cnt_size, 1);\r\n"
"        printf(\"\\n\");\r\n"
"    }\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"#endif\r\n"
"\r\n"
"void reset_mem(size_t limit, Counting_Size cnt_size)\r\n"
"{\r\n"
"    reset_stack();\r\n"
"    mem_count_init(limit, cnt_size);\r\n"
"}\r\n"
"\r\n"
"\r\n"
"void print_mem( ROM_Size_Lookup_Table Const_Data_PROM_Table[] )\r\n"
"{\r\n"
"    int i, nElem;\r\n"
"\r\n"
"    fprintf(stdout, \"\\n\\n --- Program ROM usage ---  \\n\\n\");\r\n"
"\r\n"
"    nElem = 0;\r\n"
"    while (strcmp(Const_Data_PROM_Table[nElem].file_spec, \"\") != 0) nElem++;\r\n"
"\r\n"
"    for (i = 0; i < nElem; i++)\r\n"
"    {\r\n"
"        fprintf(stdout, \"Program ROM size (%s): %d words (or instructions)\\n\", Const_Data_PROM_Table[i].file_spec, Const_Data_PROM_Table[i].PROM_size);\r\n"
"    }\r\n"
"\r\n"
"    fprintf(stdout, \"\\n\\n --- Table ROM (const data) usage ---  \\n\\n\");\r\n"
"\r\n"
"    for (i = 0; i < nElem; i++)\r\n"
"    {\r\n"
"        if (Const_Data_PROM_Table[i].Get_Const_Data_Size_Func == NULL)\r\n"
"        {\r\n"
"            fprintf(stdout, \"Error: Cannot retrieve or calculate Table ROM size of (%s)!\\n\", Const_Data_PROM_Table[i].file_spec);\r\n"
"        }\r\n"
"\r\n"
"        fprintf(stdout, \"Table ROM size (%s): %d words\\n\", Const_Data_PROM_Table[i].file_spec, Const_Data_PROM_Table[i].Get_Const_Data_Size_Func() );\r\n"
"    }\r\n"
"\r\n"
"    fprintf(stdout, \"\\n\\n --- Stack usage ---  \\n\\n\");\r\n"
"\r\n"
"    fprintf(stdout, \"Stack size: %ld words in %s() in frame #%d\\n\\n\", ((ptr_base_stack - ptr_max_stack) * sizeof(int16_t)) / sizeof(float),\r\n"
"            location_max_stack, wc_frame);\r\n"
"    print_stack_call_tree();\r\n"
"\r\n"
"    fprintf(stdout, \"Note: this is an optimistic estimate of the memory consumption assuming\\n\");\r\n"
"    fprintf(stdout, \"      that each variable (short, long or float) in the codec requires\\n\");\r\n"
"    fprintf(stdout, \"      32 bits of memory and may therefore be represented by 1 word.\\n\");\r\n"
"    fprintf(stdout, \"      The following formula is used: sizeof('memory array')/sizeof(float)\\n\\n\");\r\n"
"\r\n"
"    /* Static RAM usage */\r\n"
"    fprintf(stdout, \"\\n\\n --- Static RAM usage ---  \\n\\n\");\r\n"
"    printf(\"Peak SRAM Allocated: %i%c\\n\", (int)(Peak_RAM >> Stat_Cnt_Size), Count_suffix[Stat_Cnt_Size]);\r\n"
"\r\n"
"#ifdef MEM_COUNT_DETAILS\r\n"
"    /* Print detailed SRAM info */\r\n"
"    mem_count_summary(USE_DEFAULT);\r\n"
"#else\r\n"
"    if (Num_Records_Cur_RAM > 0)\r\n"
"    {\r\n"
"        printf(\"\\nWarning: Part of the SRAM is still allocated! Activate MEM_COUNT_DETAILS for more details.\\n\");\r\n"
"    }\r\n"
"#endif\r\n"
"\r\n"
"    return;\r\n"
"}\r\n"
"\r\n"
"\r\n"
"#undef WMC_TOOL_SKIP\r\n"
"\r\n"
"\r\n"
"#endif /* WMOPS */\r\n"
"\r\n"
"#ifndef WMOPS\r\n"
"int cntr_push_pop = 0;      /* global counter for checking balanced push_wmops()/pop_wmops() pairs when WMOPS is not activated */\r\n"
"#endif\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"
"\r\n"